// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: scalar/chains/v1beta1/types.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Any } from "../../../google/protobuf/any";

export const protobufPackage = "scalar.chains.v1beta1";

export enum BatchedCommandsStatus {
  BATCHED_COMMANDS_STATUS_UNSPECIFIED = 0,
  BATCHED_COMMANDS_STATUS_SIGNING = 1,
  BATCHED_COMMANDS_STATUS_ABORTED = 2,
  BATCHED_COMMANDS_STATUS_SIGNED = 3,
  UNRECOGNIZED = -1,
}

export function batchedCommandsStatusFromJSON(
  object: any,
): BatchedCommandsStatus {
  switch (object) {
    case 0:
    case "BATCHED_COMMANDS_STATUS_UNSPECIFIED":
      return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_UNSPECIFIED;
    case 1:
    case "BATCHED_COMMANDS_STATUS_SIGNING":
      return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNING;
    case 2:
    case "BATCHED_COMMANDS_STATUS_ABORTED":
      return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_ABORTED;
    case 3:
    case "BATCHED_COMMANDS_STATUS_SIGNED":
      return BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatchedCommandsStatus.UNRECOGNIZED;
  }
}

export function batchedCommandsStatusToJSON(
  object: BatchedCommandsStatus,
): string {
  switch (object) {
    case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_UNSPECIFIED:
      return "BATCHED_COMMANDS_STATUS_UNSPECIFIED";
    case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNING:
      return "BATCHED_COMMANDS_STATUS_SIGNING";
    case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_ABORTED:
      return "BATCHED_COMMANDS_STATUS_ABORTED";
    case BatchedCommandsStatus.BATCHED_COMMANDS_STATUS_SIGNED:
      return "BATCHED_COMMANDS_STATUS_SIGNED";
    case BatchedCommandsStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SourceTxStatus {
  STAKING_TX_STATUS_UNSPECIFIED = 0,
  STAKING_TX_STATUS_PENDING = 1,
  STAKING_TX_STATUS_CONFIRMED = 2,
  STAKING_TX_STATUS_COMPLETED = 3,
  UNRECOGNIZED = -1,
}

export function sourceTxStatusFromJSON(object: any): SourceTxStatus {
  switch (object) {
    case 0:
    case "STAKING_TX_STATUS_UNSPECIFIED":
      return SourceTxStatus.STAKING_TX_STATUS_UNSPECIFIED;
    case 1:
    case "STAKING_TX_STATUS_PENDING":
      return SourceTxStatus.STAKING_TX_STATUS_PENDING;
    case 2:
    case "STAKING_TX_STATUS_CONFIRMED":
      return SourceTxStatus.STAKING_TX_STATUS_CONFIRMED;
    case 3:
    case "STAKING_TX_STATUS_COMPLETED":
      return SourceTxStatus.STAKING_TX_STATUS_COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SourceTxStatus.UNRECOGNIZED;
  }
}

export function sourceTxStatusToJSON(object: SourceTxStatus): string {
  switch (object) {
    case SourceTxStatus.STAKING_TX_STATUS_UNSPECIFIED:
      return "STAKING_TX_STATUS_UNSPECIFIED";
    case SourceTxStatus.STAKING_TX_STATUS_PENDING:
      return "STAKING_TX_STATUS_PENDING";
    case SourceTxStatus.STAKING_TX_STATUS_CONFIRMED:
      return "STAKING_TX_STATUS_CONFIRMED";
    case SourceTxStatus.STAKING_TX_STATUS_COMPLETED:
      return "STAKING_TX_STATUS_COMPLETED";
    case SourceTxStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SigType {
  SIG_TYPE_UNSPECIFIED = 0,
  SIG_TYPE_TX = 1,
  SIG_TYPE_COMMAND = 2,
  UNRECOGNIZED = -1,
}

export function sigTypeFromJSON(object: any): SigType {
  switch (object) {
    case 0:
    case "SIG_TYPE_UNSPECIFIED":
      return SigType.SIG_TYPE_UNSPECIFIED;
    case 1:
    case "SIG_TYPE_TX":
      return SigType.SIG_TYPE_TX;
    case 2:
    case "SIG_TYPE_COMMAND":
      return SigType.SIG_TYPE_COMMAND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SigType.UNRECOGNIZED;
  }
}

export function sigTypeToJSON(object: SigType): string {
  switch (object) {
    case SigType.SIG_TYPE_UNSPECIFIED:
      return "SIG_TYPE_UNSPECIFIED";
    case SigType.SIG_TYPE_TX:
      return "SIG_TYPE_TX";
    case SigType.SIG_TYPE_COMMAND:
      return "SIG_TYPE_COMMAND";
    case SigType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DepositStatus {
  DEPOSIT_STATUS_UNSPECIFIED = 0,
  DEPOSIT_STATUS_PENDING = 1,
  DEPOSIT_STATUS_CONFIRMED = 2,
  DEPOSIT_STATUS_BURNED = 3,
  UNRECOGNIZED = -1,
}

export function depositStatusFromJSON(object: any): DepositStatus {
  switch (object) {
    case 0:
    case "DEPOSIT_STATUS_UNSPECIFIED":
      return DepositStatus.DEPOSIT_STATUS_UNSPECIFIED;
    case 1:
    case "DEPOSIT_STATUS_PENDING":
      return DepositStatus.DEPOSIT_STATUS_PENDING;
    case 2:
    case "DEPOSIT_STATUS_CONFIRMED":
      return DepositStatus.DEPOSIT_STATUS_CONFIRMED;
    case 3:
    case "DEPOSIT_STATUS_BURNED":
      return DepositStatus.DEPOSIT_STATUS_BURNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DepositStatus.UNRECOGNIZED;
  }
}

export function depositStatusToJSON(object: DepositStatus): string {
  switch (object) {
    case DepositStatus.DEPOSIT_STATUS_UNSPECIFIED:
      return "DEPOSIT_STATUS_UNSPECIFIED";
    case DepositStatus.DEPOSIT_STATUS_PENDING:
      return "DEPOSIT_STATUS_PENDING";
    case DepositStatus.DEPOSIT_STATUS_CONFIRMED:
      return "DEPOSIT_STATUS_CONFIRMED";
    case DepositStatus.DEPOSIT_STATUS_BURNED:
      return "DEPOSIT_STATUS_BURNED";
    case DepositStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Status {
  /**
   * STATUS_UNSPECIFIED - these enum values are used for bitwise operations, therefore they need to
   * be powers of 2
   */
  STATUS_UNSPECIFIED = 0,
  STATUS_INITIALIZED = 1,
  STATUS_PENDING = 2,
  STATUS_CONFIRMED = 4,
  UNRECOGNIZED = -1,
}

export function statusFromJSON(object: any): Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Status.STATUS_UNSPECIFIED;
    case 1:
    case "STATUS_INITIALIZED":
      return Status.STATUS_INITIALIZED;
    case 2:
    case "STATUS_PENDING":
      return Status.STATUS_PENDING;
    case 4:
    case "STATUS_CONFIRMED":
      return Status.STATUS_CONFIRMED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Status.UNRECOGNIZED;
  }
}

export function statusToJSON(object: Status): string {
  switch (object) {
    case Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Status.STATUS_INITIALIZED:
      return "STATUS_INITIALIZED";
    case Status.STATUS_PENDING:
      return "STATUS_PENDING";
    case Status.STATUS_CONFIRMED:
      return "STATUS_CONFIRMED";
    case Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CommandType {
  COMMAND_TYPE_UNSPECIFIED = 0,
  COMMAND_TYPE_MINT_TOKEN = 1,
  COMMAND_TYPE_DEPLOY_TOKEN = 2,
  COMMAND_TYPE_BURN_TOKEN = 3,
  COMMAND_TYPE_TRANSFER_OPERATORSHIP = 4,
  COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT = 5,
  COMMAND_TYPE_APPROVE_CONTRACT_CALL = 6,
  COMMAND_TYPE_REGISTER_CUSTODIAN_GROUP = 7,
  COMMAND_TYPE_SWITCH_PHASE = 8,
  COMMAND_TYPE_REDEEM_TOKEN = 9,
  COMMAND_TYPE_APPROVE_REDEEM_TOKEN = 10,
  UNRECOGNIZED = -1,
}

export function commandTypeFromJSON(object: any): CommandType {
  switch (object) {
    case 0:
    case "COMMAND_TYPE_UNSPECIFIED":
      return CommandType.COMMAND_TYPE_UNSPECIFIED;
    case 1:
    case "COMMAND_TYPE_MINT_TOKEN":
      return CommandType.COMMAND_TYPE_MINT_TOKEN;
    case 2:
    case "COMMAND_TYPE_DEPLOY_TOKEN":
      return CommandType.COMMAND_TYPE_DEPLOY_TOKEN;
    case 3:
    case "COMMAND_TYPE_BURN_TOKEN":
      return CommandType.COMMAND_TYPE_BURN_TOKEN;
    case 4:
    case "COMMAND_TYPE_TRANSFER_OPERATORSHIP":
      return CommandType.COMMAND_TYPE_TRANSFER_OPERATORSHIP;
    case 5:
    case "COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT":
      return CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT;
    case 6:
    case "COMMAND_TYPE_APPROVE_CONTRACT_CALL":
      return CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL;
    case 7:
    case "COMMAND_TYPE_REGISTER_CUSTODIAN_GROUP":
      return CommandType.COMMAND_TYPE_REGISTER_CUSTODIAN_GROUP;
    case 8:
    case "COMMAND_TYPE_SWITCH_PHASE":
      return CommandType.COMMAND_TYPE_SWITCH_PHASE;
    case 9:
    case "COMMAND_TYPE_REDEEM_TOKEN":
      return CommandType.COMMAND_TYPE_REDEEM_TOKEN;
    case 10:
    case "COMMAND_TYPE_APPROVE_REDEEM_TOKEN":
      return CommandType.COMMAND_TYPE_APPROVE_REDEEM_TOKEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommandType.UNRECOGNIZED;
  }
}

export function commandTypeToJSON(object: CommandType): string {
  switch (object) {
    case CommandType.COMMAND_TYPE_UNSPECIFIED:
      return "COMMAND_TYPE_UNSPECIFIED";
    case CommandType.COMMAND_TYPE_MINT_TOKEN:
      return "COMMAND_TYPE_MINT_TOKEN";
    case CommandType.COMMAND_TYPE_DEPLOY_TOKEN:
      return "COMMAND_TYPE_DEPLOY_TOKEN";
    case CommandType.COMMAND_TYPE_BURN_TOKEN:
      return "COMMAND_TYPE_BURN_TOKEN";
    case CommandType.COMMAND_TYPE_TRANSFER_OPERATORSHIP:
      return "COMMAND_TYPE_TRANSFER_OPERATORSHIP";
    case CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT:
      return "COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT";
    case CommandType.COMMAND_TYPE_APPROVE_CONTRACT_CALL:
      return "COMMAND_TYPE_APPROVE_CONTRACT_CALL";
    case CommandType.COMMAND_TYPE_REGISTER_CUSTODIAN_GROUP:
      return "COMMAND_TYPE_REGISTER_CUSTODIAN_GROUP";
    case CommandType.COMMAND_TYPE_SWITCH_PHASE:
      return "COMMAND_TYPE_SWITCH_PHASE";
    case CommandType.COMMAND_TYPE_REDEEM_TOKEN:
      return "COMMAND_TYPE_REDEEM_TOKEN";
    case CommandType.COMMAND_TYPE_APPROVE_REDEEM_TOKEN:
      return "COMMAND_TYPE_APPROVE_REDEEM_TOKEN";
    case CommandType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SourceTx {
  txId: Uint8Array;
  amount: Uint8Array;
  /** TODO: change to asset type: sats, runes, btc, etc */
  asset: string;
  destinationChain: string;
  destinationRecipientAddress: Uint8Array;
  logIndex: Long;
}

export interface CommandBatchMetadata {
  id: Uint8Array;
  commandIds: Uint8Array[];
  data: Uint8Array;
  sigHash: Uint8Array;
  status: BatchedCommandsStatus;
  keyId: string;
  prevBatchedCommandsId: Uint8Array;
  signature?: Any | undefined;
  /** Store payload of each command to create psbt */
  extraData: Uint8Array[];
}

export interface Proof {
  addresses: string[];
  weights: string[];
  threshold: string;
  signatures: string[];
}

export interface Command {
  id: Uint8Array;
  params: Uint8Array;
  keyId: string;
  maxGasCost: number;
  type: CommandType;
  /**
   * This field is used as extra data for the command, metadata is encoded in
   * the payload, it can be fee information, etc.
   */
  payload: Uint8Array;
}

export interface PollMapping {
  txId: Uint8Array;
  pollId: string;
}

export interface PollMetadata {
  chain: string;
  txId: Uint8Array;
}

export interface PollFailed {
  txId: Uint8Array;
  chain: string;
  pollId: string;
}

export interface PollExpired {
  txId: Uint8Array;
  chain: string;
  pollId: string;
}

export interface PollCompleted {
  txId: Uint8Array;
  chain: string;
  pollId: string;
}

/**
 * SigMetadata stores necessary information for external apps to map signature
 * results to chains relay transaction types
 */
export interface SigMetadata {
  type: SigType;
  chain: string;
  commandBatchId: Uint8Array;
}

/** TransferKey contains information for a transfer operatorship */
export interface TransferKey {
  txId: Uint8Array;
  nextKeyId: string;
}

export interface Asset {
  chain: string;
  symbol: string;
}

export interface Gateway {
  address: Uint8Array;
}

export interface BurnerInfo {
  burnerAddress: Uint8Array;
  tokenAddress: Uint8Array;
  destinationChain: string;
  symbol: string;
  asset: string;
  salt: Uint8Array;
}

function createBaseSourceTx(): SourceTx {
  return {
    txId: new Uint8Array(0),
    amount: new Uint8Array(0),
    asset: "",
    destinationChain: "",
    destinationRecipientAddress: new Uint8Array(0),
    logIndex: Long.UZERO,
  };
}

export const SourceTx = {
  encode(
    message: SourceTx,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.txId.length !== 0) {
      writer.uint32(10).bytes(message.txId);
    }
    if (message.amount.length !== 0) {
      writer.uint32(18).bytes(message.amount);
    }
    if (message.asset !== "") {
      writer.uint32(26).string(message.asset);
    }
    if (message.destinationChain !== "") {
      writer.uint32(34).string(message.destinationChain);
    }
    if (message.destinationRecipientAddress.length !== 0) {
      writer.uint32(42).bytes(message.destinationRecipientAddress);
    }
    if (!message.logIndex.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.logIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SourceTx {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destinationChain = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.destinationRecipientAddress = reader.bytes();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.logIndex = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceTx {
    return {
      txId: isSet(object.txId)
        ? bytesFromBase64(object.txId)
        : new Uint8Array(0),
      amount: isSet(object.amount)
        ? bytesFromBase64(object.amount)
        : new Uint8Array(0),
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      destinationChain: isSet(object.destinationChain)
        ? globalThis.String(object.destinationChain)
        : "",
      destinationRecipientAddress: isSet(object.destinationRecipientAddress)
        ? bytesFromBase64(object.destinationRecipientAddress)
        : new Uint8Array(0),
      logIndex: isSet(object.logIndex)
        ? Long.fromValue(object.logIndex)
        : Long.UZERO,
    };
  },

  toJSON(message: SourceTx): unknown {
    const obj: any = {};
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.destinationChain !== "") {
      obj.destinationChain = message.destinationChain;
    }
    if (message.destinationRecipientAddress.length !== 0) {
      obj.destinationRecipientAddress = base64FromBytes(
        message.destinationRecipientAddress,
      );
    }
    if (!message.logIndex.equals(Long.UZERO)) {
      obj.logIndex = (message.logIndex || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceTx>, I>>(base?: I): SourceTx {
    return SourceTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceTx>, I>>(object: I): SourceTx {
    const message = createBaseSourceTx();
    message.txId = object.txId ?? new Uint8Array(0);
    message.amount = object.amount ?? new Uint8Array(0);
    message.asset = object.asset ?? "";
    message.destinationChain = object.destinationChain ?? "";
    message.destinationRecipientAddress =
      object.destinationRecipientAddress ?? new Uint8Array(0);
    message.logIndex =
      object.logIndex !== undefined && object.logIndex !== null
        ? Long.fromValue(object.logIndex)
        : Long.UZERO;
    return message;
  },
};

function createBaseCommandBatchMetadata(): CommandBatchMetadata {
  return {
    id: new Uint8Array(0),
    commandIds: [],
    data: new Uint8Array(0),
    sigHash: new Uint8Array(0),
    status: 0,
    keyId: "",
    prevBatchedCommandsId: new Uint8Array(0),
    signature: undefined,
    extraData: [],
  };
}

export const CommandBatchMetadata = {
  encode(
    message: CommandBatchMetadata,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    for (const v of message.commandIds) {
      writer.uint32(18).bytes(v!);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.sigHash.length !== 0) {
      writer.uint32(34).bytes(message.sigHash);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.keyId !== "") {
      writer.uint32(50).string(message.keyId);
    }
    if (message.prevBatchedCommandsId.length !== 0) {
      writer.uint32(58).bytes(message.prevBatchedCommandsId);
    }
    if (message.signature !== undefined) {
      Any.encode(message.signature, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.extraData) {
      writer.uint32(74).bytes(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CommandBatchMetadata {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandBatchMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commandIds.push(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sigHash = reader.bytes();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.prevBatchedCommandsId = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.signature = Any.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.extraData.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandBatchMetadata {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      commandIds: globalThis.Array.isArray(object?.commandIds)
        ? object.commandIds.map((e: any) => bytesFromBase64(e))
        : [],
      data: isSet(object.data)
        ? bytesFromBase64(object.data)
        : new Uint8Array(0),
      sigHash: isSet(object.sigHash)
        ? bytesFromBase64(object.sigHash)
        : new Uint8Array(0),
      status: isSet(object.status)
        ? batchedCommandsStatusFromJSON(object.status)
        : 0,
      keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "",
      prevBatchedCommandsId: isSet(object.prevBatchedCommandsId)
        ? bytesFromBase64(object.prevBatchedCommandsId)
        : new Uint8Array(0),
      signature: isSet(object.signature)
        ? Any.fromJSON(object.signature)
        : undefined,
      extraData: globalThis.Array.isArray(object?.extraData)
        ? object.extraData.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: CommandBatchMetadata): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.commandIds?.length) {
      obj.commandIds = message.commandIds.map((e) => base64FromBytes(e));
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.sigHash.length !== 0) {
      obj.sigHash = base64FromBytes(message.sigHash);
    }
    if (message.status !== 0) {
      obj.status = batchedCommandsStatusToJSON(message.status);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.prevBatchedCommandsId.length !== 0) {
      obj.prevBatchedCommandsId = base64FromBytes(
        message.prevBatchedCommandsId,
      );
    }
    if (message.signature !== undefined) {
      obj.signature = Any.toJSON(message.signature);
    }
    if (message.extraData?.length) {
      obj.extraData = message.extraData.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandBatchMetadata>, I>>(
    base?: I,
  ): CommandBatchMetadata {
    return CommandBatchMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandBatchMetadata>, I>>(
    object: I,
  ): CommandBatchMetadata {
    const message = createBaseCommandBatchMetadata();
    message.id = object.id ?? new Uint8Array(0);
    message.commandIds = object.commandIds?.map((e) => e) || [];
    message.data = object.data ?? new Uint8Array(0);
    message.sigHash = object.sigHash ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.keyId = object.keyId ?? "";
    message.prevBatchedCommandsId =
      object.prevBatchedCommandsId ?? new Uint8Array(0);
    message.signature =
      object.signature !== undefined && object.signature !== null
        ? Any.fromPartial(object.signature)
        : undefined;
    message.extraData = object.extraData?.map((e) => e) || [];
    return message;
  },
};

function createBaseProof(): Proof {
  return { addresses: [], weights: [], threshold: "", signatures: [] };
}

export const Proof = {
  encode(message: Proof, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.addresses) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.weights) {
      writer.uint32(18).string(v!);
    }
    if (message.threshold !== "") {
      writer.uint32(26).string(message.threshold);
    }
    for (const v of message.signatures) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Proof {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.weights.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.threshold = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signatures.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Proof {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
      weights: globalThis.Array.isArray(object?.weights)
        ? object.weights.map((e: any) => globalThis.String(e))
        : [],
      threshold: isSet(object.threshold)
        ? globalThis.String(object.threshold)
        : "",
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Proof): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    if (message.weights?.length) {
      obj.weights = message.weights;
    }
    if (message.threshold !== "") {
      obj.threshold = message.threshold;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Proof>, I>>(base?: I): Proof {
    return Proof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Proof>, I>>(object: I): Proof {
    const message = createBaseProof();
    message.addresses = object.addresses?.map((e) => e) || [];
    message.weights = object.weights?.map((e) => e) || [];
    message.threshold = object.threshold ?? "";
    message.signatures = object.signatures?.map((e) => e) || [];
    return message;
  },
};

function createBaseCommand(): Command {
  return {
    id: new Uint8Array(0),
    params: new Uint8Array(0),
    keyId: "",
    maxGasCost: 0,
    type: 0,
    payload: new Uint8Array(0),
  };
}

export const Command = {
  encode(
    message: Command,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.params.length !== 0) {
      writer.uint32(18).bytes(message.params);
    }
    if (message.keyId !== "") {
      writer.uint32(26).string(message.keyId);
    }
    if (message.maxGasCost !== 0) {
      writer.uint32(32).uint32(message.maxGasCost);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(50).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Command {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.params = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxGasCost = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Command {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      params: isSet(object.params)
        ? bytesFromBase64(object.params)
        : new Uint8Array(0),
      keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "",
      maxGasCost: isSet(object.maxGasCost)
        ? globalThis.Number(object.maxGasCost)
        : 0,
      type: isSet(object.type) ? commandTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload)
        ? bytesFromBase64(object.payload)
        : new Uint8Array(0),
    };
  },

  toJSON(message: Command): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.params.length !== 0) {
      obj.params = base64FromBytes(message.params);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    if (message.maxGasCost !== 0) {
      obj.maxGasCost = Math.round(message.maxGasCost);
    }
    if (message.type !== 0) {
      obj.type = commandTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Command>, I>>(base?: I): Command {
    return Command.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Command>, I>>(object: I): Command {
    const message = createBaseCommand();
    message.id = object.id ?? new Uint8Array(0);
    message.params = object.params ?? new Uint8Array(0);
    message.keyId = object.keyId ?? "";
    message.maxGasCost = object.maxGasCost ?? 0;
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBasePollMapping(): PollMapping {
  return { txId: new Uint8Array(0), pollId: "" };
}

export const PollMapping = {
  encode(
    message: PollMapping,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.txId.length !== 0) {
      writer.uint32(10).bytes(message.txId);
    }
    if (message.pollId !== "") {
      writer.uint32(18).string(message.pollId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PollMapping {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pollId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollMapping {
    return {
      txId: isSet(object.txId)
        ? bytesFromBase64(object.txId)
        : new Uint8Array(0),
      pollId: isSet(object.pollId) ? globalThis.String(object.pollId) : "",
    };
  },

  toJSON(message: PollMapping): unknown {
    const obj: any = {};
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.pollId !== "") {
      obj.pollId = message.pollId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PollMapping>, I>>(base?: I): PollMapping {
    return PollMapping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollMapping>, I>>(
    object: I,
  ): PollMapping {
    const message = createBasePollMapping();
    message.txId = object.txId ?? new Uint8Array(0);
    message.pollId = object.pollId ?? "";
    return message;
  },
};

function createBasePollMetadata(): PollMetadata {
  return { chain: "", txId: new Uint8Array(0) };
}

export const PollMetadata = {
  encode(
    message: PollMetadata,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.txId.length !== 0) {
      writer.uint32(18).bytes(message.txId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PollMetadata {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.txId = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollMetadata {
    return {
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      txId: isSet(object.txId)
        ? bytesFromBase64(object.txId)
        : new Uint8Array(0),
    };
  },

  toJSON(message: PollMetadata): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PollMetadata>, I>>(
    base?: I,
  ): PollMetadata {
    return PollMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollMetadata>, I>>(
    object: I,
  ): PollMetadata {
    const message = createBasePollMetadata();
    message.chain = object.chain ?? "";
    message.txId = object.txId ?? new Uint8Array(0);
    return message;
  },
};

function createBasePollFailed(): PollFailed {
  return { txId: new Uint8Array(0), chain: "", pollId: "" };
}

export const PollFailed = {
  encode(
    message: PollFailed,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.txId.length !== 0) {
      writer.uint32(10).bytes(message.txId);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.pollId !== "") {
      writer.uint32(26).string(message.pollId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PollFailed {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollFailed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pollId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollFailed {
    return {
      txId: isSet(object.txId)
        ? bytesFromBase64(object.txId)
        : new Uint8Array(0),
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      pollId: isSet(object.pollId) ? globalThis.String(object.pollId) : "",
    };
  },

  toJSON(message: PollFailed): unknown {
    const obj: any = {};
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.pollId !== "") {
      obj.pollId = message.pollId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PollFailed>, I>>(base?: I): PollFailed {
    return PollFailed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollFailed>, I>>(
    object: I,
  ): PollFailed {
    const message = createBasePollFailed();
    message.txId = object.txId ?? new Uint8Array(0);
    message.chain = object.chain ?? "";
    message.pollId = object.pollId ?? "";
    return message;
  },
};

function createBasePollExpired(): PollExpired {
  return { txId: new Uint8Array(0), chain: "", pollId: "" };
}

export const PollExpired = {
  encode(
    message: PollExpired,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.txId.length !== 0) {
      writer.uint32(10).bytes(message.txId);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.pollId !== "") {
      writer.uint32(26).string(message.pollId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PollExpired {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollExpired();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pollId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollExpired {
    return {
      txId: isSet(object.txId)
        ? bytesFromBase64(object.txId)
        : new Uint8Array(0),
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      pollId: isSet(object.pollId) ? globalThis.String(object.pollId) : "",
    };
  },

  toJSON(message: PollExpired): unknown {
    const obj: any = {};
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.pollId !== "") {
      obj.pollId = message.pollId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PollExpired>, I>>(base?: I): PollExpired {
    return PollExpired.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollExpired>, I>>(
    object: I,
  ): PollExpired {
    const message = createBasePollExpired();
    message.txId = object.txId ?? new Uint8Array(0);
    message.chain = object.chain ?? "";
    message.pollId = object.pollId ?? "";
    return message;
  },
};

function createBasePollCompleted(): PollCompleted {
  return { txId: new Uint8Array(0), chain: "", pollId: "" };
}

export const PollCompleted = {
  encode(
    message: PollCompleted,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.txId.length !== 0) {
      writer.uint32(10).bytes(message.txId);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.pollId !== "") {
      writer.uint32(26).string(message.pollId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PollCompleted {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pollId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollCompleted {
    return {
      txId: isSet(object.txId)
        ? bytesFromBase64(object.txId)
        : new Uint8Array(0),
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      pollId: isSet(object.pollId) ? globalThis.String(object.pollId) : "",
    };
  },

  toJSON(message: PollCompleted): unknown {
    const obj: any = {};
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.pollId !== "") {
      obj.pollId = message.pollId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PollCompleted>, I>>(
    base?: I,
  ): PollCompleted {
    return PollCompleted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollCompleted>, I>>(
    object: I,
  ): PollCompleted {
    const message = createBasePollCompleted();
    message.txId = object.txId ?? new Uint8Array(0);
    message.chain = object.chain ?? "";
    message.pollId = object.pollId ?? "";
    return message;
  },
};

function createBaseSigMetadata(): SigMetadata {
  return { type: 0, chain: "", commandBatchId: new Uint8Array(0) };
}

export const SigMetadata = {
  encode(
    message: SigMetadata,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.commandBatchId.length !== 0) {
      writer.uint32(26).bytes(message.commandBatchId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SigMetadata {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSigMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.commandBatchId = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SigMetadata {
    return {
      type: isSet(object.type) ? sigTypeFromJSON(object.type) : 0,
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      commandBatchId: isSet(object.commandBatchId)
        ? bytesFromBase64(object.commandBatchId)
        : new Uint8Array(0),
    };
  },

  toJSON(message: SigMetadata): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = sigTypeToJSON(message.type);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.commandBatchId.length !== 0) {
      obj.commandBatchId = base64FromBytes(message.commandBatchId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SigMetadata>, I>>(base?: I): SigMetadata {
    return SigMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SigMetadata>, I>>(
    object: I,
  ): SigMetadata {
    const message = createBaseSigMetadata();
    message.type = object.type ?? 0;
    message.chain = object.chain ?? "";
    message.commandBatchId = object.commandBatchId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransferKey(): TransferKey {
  return { txId: new Uint8Array(0), nextKeyId: "" };
}

export const TransferKey = {
  encode(
    message: TransferKey,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.txId.length !== 0) {
      writer.uint32(10).bytes(message.txId);
    }
    if (message.nextKeyId !== "") {
      writer.uint32(26).string(message.nextKeyId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransferKey {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txId = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextKeyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferKey {
    return {
      txId: isSet(object.txId)
        ? bytesFromBase64(object.txId)
        : new Uint8Array(0),
      nextKeyId: isSet(object.nextKeyId)
        ? globalThis.String(object.nextKeyId)
        : "",
    };
  },

  toJSON(message: TransferKey): unknown {
    const obj: any = {};
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    if (message.nextKeyId !== "") {
      obj.nextKeyId = message.nextKeyId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TransferKey>, I>>(base?: I): TransferKey {
    return TransferKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TransferKey>, I>>(
    object: I,
  ): TransferKey {
    const message = createBaseTransferKey();
    message.txId = object.txId ?? new Uint8Array(0);
    message.nextKeyId = object.nextKeyId ?? "";
    return message;
  },
};

function createBaseAsset(): Asset {
  return { chain: "", symbol: "" };
}

export const Asset = {
  encode(message: Asset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chain !== "") {
      writer.uint32(10).string(message.chain);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Asset {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Asset>, I>>(base?: I): Asset {
    return Asset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Asset>, I>>(object: I): Asset {
    const message = createBaseAsset();
    message.chain = object.chain ?? "";
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseGateway(): Gateway {
  return { address: new Uint8Array(0) };
}

export const Gateway = {
  encode(
    message: Gateway,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.address.length !== 0) {
      writer.uint32(10).bytes(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Gateway {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateway();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Gateway {
    return {
      address: isSet(object.address)
        ? bytesFromBase64(object.address)
        : new Uint8Array(0),
    };
  },

  toJSON(message: Gateway): unknown {
    const obj: any = {};
    if (message.address.length !== 0) {
      obj.address = base64FromBytes(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Gateway>, I>>(base?: I): Gateway {
    return Gateway.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Gateway>, I>>(object: I): Gateway {
    const message = createBaseGateway();
    message.address = object.address ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBurnerInfo(): BurnerInfo {
  return {
    burnerAddress: new Uint8Array(0),
    tokenAddress: new Uint8Array(0),
    destinationChain: "",
    symbol: "",
    asset: "",
    salt: new Uint8Array(0),
  };
}

export const BurnerInfo = {
  encode(
    message: BurnerInfo,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.burnerAddress.length !== 0) {
      writer.uint32(10).bytes(message.burnerAddress);
    }
    if (message.tokenAddress.length !== 0) {
      writer.uint32(18).bytes(message.tokenAddress);
    }
    if (message.destinationChain !== "") {
      writer.uint32(26).string(message.destinationChain);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.asset !== "") {
      writer.uint32(42).string(message.asset);
    }
    if (message.salt.length !== 0) {
      writer.uint32(50).bytes(message.salt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BurnerInfo {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBurnerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.burnerAddress = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenAddress = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinationChain = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.salt = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BurnerInfo {
    return {
      burnerAddress: isSet(object.burnerAddress)
        ? bytesFromBase64(object.burnerAddress)
        : new Uint8Array(0),
      tokenAddress: isSet(object.tokenAddress)
        ? bytesFromBase64(object.tokenAddress)
        : new Uint8Array(0),
      destinationChain: isSet(object.destinationChain)
        ? globalThis.String(object.destinationChain)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      salt: isSet(object.salt)
        ? bytesFromBase64(object.salt)
        : new Uint8Array(0),
    };
  },

  toJSON(message: BurnerInfo): unknown {
    const obj: any = {};
    if (message.burnerAddress.length !== 0) {
      obj.burnerAddress = base64FromBytes(message.burnerAddress);
    }
    if (message.tokenAddress.length !== 0) {
      obj.tokenAddress = base64FromBytes(message.tokenAddress);
    }
    if (message.destinationChain !== "") {
      obj.destinationChain = message.destinationChain;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.salt.length !== 0) {
      obj.salt = base64FromBytes(message.salt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BurnerInfo>, I>>(base?: I): BurnerInfo {
    return BurnerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BurnerInfo>, I>>(
    object: I,
  ): BurnerInfo {
    const message = createBaseBurnerInfo();
    message.burnerAddress = object.burnerAddress ?? new Uint8Array(0);
    message.tokenAddress = object.tokenAddress ?? new Uint8Array(0);
    message.destinationChain = object.destinationChain ?? "";
    message.symbol = object.symbol ?? "";
    message.asset = object.asset ?? "";
    message.salt = object.salt ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
