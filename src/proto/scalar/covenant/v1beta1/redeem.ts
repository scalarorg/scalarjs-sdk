// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: scalar/covenant/v1beta1/redeem.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Phase, phaseFromJSON, phaseToJSON } from "../exported/v1beta1/types";

export const protobufPackage = "scalar.covenant.v1beta1";

export interface Reservation {
  request: string;
  amount: Long;
}

export interface UTXO {
  txid: Uint8Array;
  vout: number;
  scriptPubkey: Uint8Array;
  amountInSats: Long;
  /** Reserved amount for each request id */
  reservations: Reservation[];
}

export interface UTXOSnapshot {
  custodianGroupUid: Uint8Array;
  blockHeight: Long;
  utxos: UTXO[];
}

export interface RedeemSession {
  custodianGroupUid: Uint8Array;
  sequence: Long;
  currentPhase: Phase;
  lastRedeemTx: Uint8Array;
  isSwitching: boolean;
  phaseExpiredAt: Long;
}

export interface ExpiredEvmSession {
  custodianGroupUid: Uint8Array;
  chain: string;
  sequence: Long;
  currentPhase: Phase;
  tokens: string[];
}

function createBaseReservation(): Reservation {
  return { request: "", amount: Long.UZERO };
}

export const Reservation = {
  encode(
    message: Reservation,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.request !== "") {
      writer.uint32(10).string(message.request);
    }
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Reservation {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.request = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reservation {
    return {
      request: isSet(object.request) ? globalThis.String(object.request) : "",
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
    };
  },

  toJSON(message: Reservation): unknown {
    const obj: any = {};
    if (message.request !== "") {
      obj.request = message.request;
    }
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reservation>, I>>(base?: I): Reservation {
    return Reservation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reservation>, I>>(
    object: I,
  ): Reservation {
    const message = createBaseReservation();
    message.request = object.request ?? "";
    message.amount =
      object.amount !== undefined && object.amount !== null
        ? Long.fromValue(object.amount)
        : Long.UZERO;
    return message;
  },
};

function createBaseUTXO(): UTXO {
  return {
    txid: new Uint8Array(0),
    vout: 0,
    scriptPubkey: new Uint8Array(0),
    amountInSats: Long.UZERO,
    reservations: [],
  };
}

export const UTXO = {
  encode(message: UTXO, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.txid.length !== 0) {
      writer.uint32(10).bytes(message.txid);
    }
    if (message.vout !== 0) {
      writer.uint32(16).uint32(message.vout);
    }
    if (message.scriptPubkey.length !== 0) {
      writer.uint32(26).bytes(message.scriptPubkey);
    }
    if (!message.amountInSats.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.amountInSats);
    }
    for (const v of message.reservations) {
      Reservation.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UTXO {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTXO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.txid = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.vout = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.scriptPubkey = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amountInSats = reader.uint64() as Long;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reservations.push(
            Reservation.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTXO {
    return {
      txid: isSet(object.txid)
        ? bytesFromBase64(object.txid)
        : new Uint8Array(0),
      vout: isSet(object.vout) ? globalThis.Number(object.vout) : 0,
      scriptPubkey: isSet(object.scriptPubkey)
        ? bytesFromBase64(object.scriptPubkey)
        : new Uint8Array(0),
      amountInSats: isSet(object.amountInSats)
        ? Long.fromValue(object.amountInSats)
        : Long.UZERO,
      reservations: globalThis.Array.isArray(object?.reservations)
        ? object.reservations.map((e: any) => Reservation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UTXO): unknown {
    const obj: any = {};
    if (message.txid.length !== 0) {
      obj.txid = base64FromBytes(message.txid);
    }
    if (message.vout !== 0) {
      obj.vout = Math.round(message.vout);
    }
    if (message.scriptPubkey.length !== 0) {
      obj.scriptPubkey = base64FromBytes(message.scriptPubkey);
    }
    if (!message.amountInSats.equals(Long.UZERO)) {
      obj.amountInSats = (message.amountInSats || Long.UZERO).toString();
    }
    if (message.reservations?.length) {
      obj.reservations = message.reservations.map((e) => Reservation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UTXO>, I>>(base?: I): UTXO {
    return UTXO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UTXO>, I>>(object: I): UTXO {
    const message = createBaseUTXO();
    message.txid = object.txid ?? new Uint8Array(0);
    message.vout = object.vout ?? 0;
    message.scriptPubkey = object.scriptPubkey ?? new Uint8Array(0);
    message.amountInSats =
      object.amountInSats !== undefined && object.amountInSats !== null
        ? Long.fromValue(object.amountInSats)
        : Long.UZERO;
    message.reservations =
      object.reservations?.map((e) => Reservation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUTXOSnapshot(): UTXOSnapshot {
  return {
    custodianGroupUid: new Uint8Array(0),
    blockHeight: Long.UZERO,
    utxos: [],
  };
}

export const UTXOSnapshot = {
  encode(
    message: UTXOSnapshot,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.custodianGroupUid.length !== 0) {
      writer.uint32(10).bytes(message.custodianGroupUid);
    }
    if (!message.blockHeight.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.blockHeight);
    }
    for (const v of message.utxos) {
      UTXO.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UTXOSnapshot {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTXOSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.custodianGroupUid = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockHeight = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.utxos.push(UTXO.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTXOSnapshot {
    return {
      custodianGroupUid: isSet(object.custodianGroupUid)
        ? bytesFromBase64(object.custodianGroupUid)
        : new Uint8Array(0),
      blockHeight: isSet(object.blockHeight)
        ? Long.fromValue(object.blockHeight)
        : Long.UZERO,
      utxos: globalThis.Array.isArray(object?.utxos)
        ? object.utxos.map((e: any) => UTXO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UTXOSnapshot): unknown {
    const obj: any = {};
    if (message.custodianGroupUid.length !== 0) {
      obj.custodianGroupUid = base64FromBytes(message.custodianGroupUid);
    }
    if (!message.blockHeight.equals(Long.UZERO)) {
      obj.blockHeight = (message.blockHeight || Long.UZERO).toString();
    }
    if (message.utxos?.length) {
      obj.utxos = message.utxos.map((e) => UTXO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UTXOSnapshot>, I>>(
    base?: I,
  ): UTXOSnapshot {
    return UTXOSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UTXOSnapshot>, I>>(
    object: I,
  ): UTXOSnapshot {
    const message = createBaseUTXOSnapshot();
    message.custodianGroupUid = object.custodianGroupUid ?? new Uint8Array(0);
    message.blockHeight =
      object.blockHeight !== undefined && object.blockHeight !== null
        ? Long.fromValue(object.blockHeight)
        : Long.UZERO;
    message.utxos = object.utxos?.map((e) => UTXO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRedeemSession(): RedeemSession {
  return {
    custodianGroupUid: new Uint8Array(0),
    sequence: Long.UZERO,
    currentPhase: 0,
    lastRedeemTx: new Uint8Array(0),
    isSwitching: false,
    phaseExpiredAt: Long.UZERO,
  };
}

export const RedeemSession = {
  encode(
    message: RedeemSession,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.custodianGroupUid.length !== 0) {
      writer.uint32(10).bytes(message.custodianGroupUid);
    }
    if (!message.sequence.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.sequence);
    }
    if (message.currentPhase !== 0) {
      writer.uint32(24).int32(message.currentPhase);
    }
    if (message.lastRedeemTx.length !== 0) {
      writer.uint32(34).bytes(message.lastRedeemTx);
    }
    if (message.isSwitching !== false) {
      writer.uint32(40).bool(message.isSwitching);
    }
    if (!message.phaseExpiredAt.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.phaseExpiredAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RedeemSession {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedeemSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.custodianGroupUid = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequence = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.currentPhase = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastRedeemTx = reader.bytes();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isSwitching = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.phaseExpiredAt = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedeemSession {
    return {
      custodianGroupUid: isSet(object.custodianGroupUid)
        ? bytesFromBase64(object.custodianGroupUid)
        : new Uint8Array(0),
      sequence: isSet(object.sequence)
        ? Long.fromValue(object.sequence)
        : Long.UZERO,
      currentPhase: isSet(object.currentPhase)
        ? phaseFromJSON(object.currentPhase)
        : 0,
      lastRedeemTx: isSet(object.lastRedeemTx)
        ? bytesFromBase64(object.lastRedeemTx)
        : new Uint8Array(0),
      isSwitching: isSet(object.isSwitching)
        ? globalThis.Boolean(object.isSwitching)
        : false,
      phaseExpiredAt: isSet(object.phaseExpiredAt)
        ? Long.fromValue(object.phaseExpiredAt)
        : Long.UZERO,
    };
  },

  toJSON(message: RedeemSession): unknown {
    const obj: any = {};
    if (message.custodianGroupUid.length !== 0) {
      obj.custodianGroupUid = base64FromBytes(message.custodianGroupUid);
    }
    if (!message.sequence.equals(Long.UZERO)) {
      obj.sequence = (message.sequence || Long.UZERO).toString();
    }
    if (message.currentPhase !== 0) {
      obj.currentPhase = phaseToJSON(message.currentPhase);
    }
    if (message.lastRedeemTx.length !== 0) {
      obj.lastRedeemTx = base64FromBytes(message.lastRedeemTx);
    }
    if (message.isSwitching !== false) {
      obj.isSwitching = message.isSwitching;
    }
    if (!message.phaseExpiredAt.equals(Long.UZERO)) {
      obj.phaseExpiredAt = (message.phaseExpiredAt || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedeemSession>, I>>(
    base?: I,
  ): RedeemSession {
    return RedeemSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedeemSession>, I>>(
    object: I,
  ): RedeemSession {
    const message = createBaseRedeemSession();
    message.custodianGroupUid = object.custodianGroupUid ?? new Uint8Array(0);
    message.sequence =
      object.sequence !== undefined && object.sequence !== null
        ? Long.fromValue(object.sequence)
        : Long.UZERO;
    message.currentPhase = object.currentPhase ?? 0;
    message.lastRedeemTx = object.lastRedeemTx ?? new Uint8Array(0);
    message.isSwitching = object.isSwitching ?? false;
    message.phaseExpiredAt =
      object.phaseExpiredAt !== undefined && object.phaseExpiredAt !== null
        ? Long.fromValue(object.phaseExpiredAt)
        : Long.UZERO;
    return message;
  },
};

function createBaseExpiredEvmSession(): ExpiredEvmSession {
  return {
    custodianGroupUid: new Uint8Array(0),
    chain: "",
    sequence: Long.UZERO,
    currentPhase: 0,
    tokens: [],
  };
}

export const ExpiredEvmSession = {
  encode(
    message: ExpiredEvmSession,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.custodianGroupUid.length !== 0) {
      writer.uint32(10).bytes(message.custodianGroupUid);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (!message.sequence.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.sequence);
    }
    if (message.currentPhase !== 0) {
      writer.uint32(32).int32(message.currentPhase);
    }
    for (const v of message.tokens) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExpiredEvmSession {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpiredEvmSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.custodianGroupUid = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sequence = reader.uint64() as Long;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.currentPhase = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tokens.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExpiredEvmSession {
    return {
      custodianGroupUid: isSet(object.custodianGroupUid)
        ? bytesFromBase64(object.custodianGroupUid)
        : new Uint8Array(0),
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      sequence: isSet(object.sequence)
        ? Long.fromValue(object.sequence)
        : Long.UZERO,
      currentPhase: isSet(object.currentPhase)
        ? phaseFromJSON(object.currentPhase)
        : 0,
      tokens: globalThis.Array.isArray(object?.tokens)
        ? object.tokens.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ExpiredEvmSession): unknown {
    const obj: any = {};
    if (message.custodianGroupUid.length !== 0) {
      obj.custodianGroupUid = base64FromBytes(message.custodianGroupUid);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (!message.sequence.equals(Long.UZERO)) {
      obj.sequence = (message.sequence || Long.UZERO).toString();
    }
    if (message.currentPhase !== 0) {
      obj.currentPhase = phaseToJSON(message.currentPhase);
    }
    if (message.tokens?.length) {
      obj.tokens = message.tokens;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExpiredEvmSession>, I>>(
    base?: I,
  ): ExpiredEvmSession {
    return ExpiredEvmSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExpiredEvmSession>, I>>(
    object: I,
  ): ExpiredEvmSession {
    const message = createBaseExpiredEvmSession();
    message.custodianGroupUid = object.custodianGroupUid ?? new Uint8Array(0);
    message.chain = object.chain ?? "";
    message.sequence =
      object.sequence !== undefined && object.sequence !== null
        ? Long.fromValue(object.sequence)
        : Long.UZERO;
    message.currentPhase = object.currentPhase ?? 0;
    message.tokens = object.tokens?.map((e) => e) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
