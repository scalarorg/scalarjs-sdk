// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: scalar/covenant/v1beta1/tx.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { TapScriptSigsMap } from "../exported/v1beta1/types";
import {
  Custodian,
  CustodianGroup,
  Status,
  statusFromJSON,
  statusToJSON,
} from "./types";

export const protobufPackage = "scalar.covenant.v1beta1";

export interface CreateCustodianRequest {
  sender: Uint8Array;
  name: string;
  bitcoinPubkey: Uint8Array;
  status: Status;
  description: string;
}

export interface CreateCustodianResponse {
  custodian?: Custodian | undefined;
}

/** Pubkey used as key for lookup custodian to update other values */
export interface UpdateCustodianRequest {
  sender: Uint8Array;
  bitcoinPubkey: Uint8Array;
  name: string;
  status: Status;
  description: string;
}

export interface UpdateCustodianResponse {
  custodian?: Custodian | undefined;
}

export interface CreateCustodianGroupRequest {
  sender: Uint8Array;
  uid: string;
  name: string;
  quorum: number;
  status: Status;
  description: string;
  custodian: Uint8Array[];
}

export interface CreateCustodianGroupResponse {
  group?: CustodianGroup | undefined;
}

export interface UpdateCustodianGroupRequest {
  sender: Uint8Array;
  uid: string;
  name: string;
  quorum: number;
  status: Status;
  description: string;
  custodian: Uint8Array[];
}

export interface UpdateCustodianGroupResponse {
  group?: CustodianGroup | undefined;
}

export interface AddCustodianToGroupRequest {
  sender: Uint8Array;
  /** CustodianGroup uid */
  guid: string;
  custodianPubkey: Uint8Array;
  description: string;
}

export interface RemoveCustodianFromGroupRequest {
  sender: Uint8Array;
  /** CustodianGroup uid */
  guid: string;
  custodianPubkey: Uint8Array;
  description: string;
}

export interface CustodianToGroupResponse {
  group?: CustodianGroup | undefined;
}

export interface SubmitTapScriptSigsRequest {
  sender: Uint8Array;
  sigId: Long;
  listOfTapScriptSigsMap: TapScriptSigsMap[];
}

export interface SubmitTapScriptSigsResponse {}

/** Rotate key for custodian group */
export interface RotateKeyRequest {
  sender: Uint8Array;
  chain: string;
}

export interface RotateKeyResponse {}

function createBaseCreateCustodianRequest(): CreateCustodianRequest {
  return {
    sender: new Uint8Array(0),
    name: "",
    bitcoinPubkey: new Uint8Array(0),
    status: 0,
    description: "",
  };
}

export const CreateCustodianRequest = {
  encode(
    message: CreateCustodianRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.bitcoinPubkey.length !== 0) {
      writer.uint32(26).bytes(message.bitcoinPubkey);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CreateCustodianRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustodianRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bitcoinPubkey = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustodianRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      bitcoinPubkey: isSet(object.bitcoinPubkey)
        ? bytesFromBase64(object.bitcoinPubkey)
        : new Uint8Array(0),
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
    };
  },

  toJSON(message: CreateCustodianRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.bitcoinPubkey.length !== 0) {
      obj.bitcoinPubkey = base64FromBytes(message.bitcoinPubkey);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustodianRequest>, I>>(
    base?: I,
  ): CreateCustodianRequest {
    return CreateCustodianRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustodianRequest>, I>>(
    object: I,
  ): CreateCustodianRequest {
    const message = createBaseCreateCustodianRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.name = object.name ?? "";
    message.bitcoinPubkey = object.bitcoinPubkey ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCreateCustodianResponse(): CreateCustodianResponse {
  return { custodian: undefined };
}

export const CreateCustodianResponse = {
  encode(
    message: CreateCustodianResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.custodian !== undefined) {
      Custodian.encode(message.custodian, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CreateCustodianResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustodianResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.custodian = Custodian.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustodianResponse {
    return {
      custodian: isSet(object.custodian)
        ? Custodian.fromJSON(object.custodian)
        : undefined,
    };
  },

  toJSON(message: CreateCustodianResponse): unknown {
    const obj: any = {};
    if (message.custodian !== undefined) {
      obj.custodian = Custodian.toJSON(message.custodian);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustodianResponse>, I>>(
    base?: I,
  ): CreateCustodianResponse {
    return CreateCustodianResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustodianResponse>, I>>(
    object: I,
  ): CreateCustodianResponse {
    const message = createBaseCreateCustodianResponse();
    message.custodian =
      object.custodian !== undefined && object.custodian !== null
        ? Custodian.fromPartial(object.custodian)
        : undefined;
    return message;
  },
};

function createBaseUpdateCustodianRequest(): UpdateCustodianRequest {
  return {
    sender: new Uint8Array(0),
    bitcoinPubkey: new Uint8Array(0),
    name: "",
    status: 0,
    description: "",
  };
}

export const UpdateCustodianRequest = {
  encode(
    message: UpdateCustodianRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.bitcoinPubkey.length !== 0) {
      writer.uint32(18).bytes(message.bitcoinPubkey);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): UpdateCustodianRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustodianRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bitcoinPubkey = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustodianRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      bitcoinPubkey: isSet(object.bitcoinPubkey)
        ? bytesFromBase64(object.bitcoinPubkey)
        : new Uint8Array(0),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
    };
  },

  toJSON(message: UpdateCustodianRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.bitcoinPubkey.length !== 0) {
      obj.bitcoinPubkey = base64FromBytes(message.bitcoinPubkey);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCustodianRequest>, I>>(
    base?: I,
  ): UpdateCustodianRequest {
    return UpdateCustodianRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCustodianRequest>, I>>(
    object: I,
  ): UpdateCustodianRequest {
    const message = createBaseUpdateCustodianRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.bitcoinPubkey = object.bitcoinPubkey ?? new Uint8Array(0);
    message.name = object.name ?? "";
    message.status = object.status ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseUpdateCustodianResponse(): UpdateCustodianResponse {
  return { custodian: undefined };
}

export const UpdateCustodianResponse = {
  encode(
    message: UpdateCustodianResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.custodian !== undefined) {
      Custodian.encode(message.custodian, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): UpdateCustodianResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustodianResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.custodian = Custodian.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustodianResponse {
    return {
      custodian: isSet(object.custodian)
        ? Custodian.fromJSON(object.custodian)
        : undefined,
    };
  },

  toJSON(message: UpdateCustodianResponse): unknown {
    const obj: any = {};
    if (message.custodian !== undefined) {
      obj.custodian = Custodian.toJSON(message.custodian);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCustodianResponse>, I>>(
    base?: I,
  ): UpdateCustodianResponse {
    return UpdateCustodianResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCustodianResponse>, I>>(
    object: I,
  ): UpdateCustodianResponse {
    const message = createBaseUpdateCustodianResponse();
    message.custodian =
      object.custodian !== undefined && object.custodian !== null
        ? Custodian.fromPartial(object.custodian)
        : undefined;
    return message;
  },
};

function createBaseCreateCustodianGroupRequest(): CreateCustodianGroupRequest {
  return {
    sender: new Uint8Array(0),
    uid: "",
    name: "",
    quorum: 0,
    status: 0,
    description: "",
    custodian: [],
  };
}

export const CreateCustodianGroupRequest = {
  encode(
    message: CreateCustodianGroupRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.quorum !== 0) {
      writer.uint32(32).uint32(message.quorum);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    for (const v of message.custodian) {
      writer.uint32(58).bytes(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CreateCustodianGroupRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustodianGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quorum = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.custodian.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustodianGroupRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      quorum: isSet(object.quorum) ? globalThis.Number(object.quorum) : 0,
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      custodian: globalThis.Array.isArray(object?.custodian)
        ? object.custodian.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: CreateCustodianGroupRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.quorum !== 0) {
      obj.quorum = Math.round(message.quorum);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.custodian?.length) {
      obj.custodian = message.custodian.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustodianGroupRequest>, I>>(
    base?: I,
  ): CreateCustodianGroupRequest {
    return CreateCustodianGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustodianGroupRequest>, I>>(
    object: I,
  ): CreateCustodianGroupRequest {
    const message = createBaseCreateCustodianGroupRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.uid = object.uid ?? "";
    message.name = object.name ?? "";
    message.quorum = object.quorum ?? 0;
    message.status = object.status ?? 0;
    message.description = object.description ?? "";
    message.custodian = object.custodian?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateCustodianGroupResponse(): CreateCustodianGroupResponse {
  return { group: undefined };
}

export const CreateCustodianGroupResponse = {
  encode(
    message: CreateCustodianGroupResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.group !== undefined) {
      CustodianGroup.encode(message.group, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CreateCustodianGroupResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustodianGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = CustodianGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustodianGroupResponse {
    return {
      group: isSet(object.group)
        ? CustodianGroup.fromJSON(object.group)
        : undefined,
    };
  },

  toJSON(message: CreateCustodianGroupResponse): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = CustodianGroup.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustodianGroupResponse>, I>>(
    base?: I,
  ): CreateCustodianGroupResponse {
    return CreateCustodianGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustodianGroupResponse>, I>>(
    object: I,
  ): CreateCustodianGroupResponse {
    const message = createBaseCreateCustodianGroupResponse();
    message.group =
      object.group !== undefined && object.group !== null
        ? CustodianGroup.fromPartial(object.group)
        : undefined;
    return message;
  },
};

function createBaseUpdateCustodianGroupRequest(): UpdateCustodianGroupRequest {
  return {
    sender: new Uint8Array(0),
    uid: "",
    name: "",
    quorum: 0,
    status: 0,
    description: "",
    custodian: [],
  };
}

export const UpdateCustodianGroupRequest = {
  encode(
    message: UpdateCustodianGroupRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.quorum !== 0) {
      writer.uint32(32).uint32(message.quorum);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    for (const v of message.custodian) {
      writer.uint32(58).bytes(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): UpdateCustodianGroupRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustodianGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quorum = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.custodian.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustodianGroupRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      quorum: isSet(object.quorum) ? globalThis.Number(object.quorum) : 0,
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      custodian: globalThis.Array.isArray(object?.custodian)
        ? object.custodian.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: UpdateCustodianGroupRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.quorum !== 0) {
      obj.quorum = Math.round(message.quorum);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.custodian?.length) {
      obj.custodian = message.custodian.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCustodianGroupRequest>, I>>(
    base?: I,
  ): UpdateCustodianGroupRequest {
    return UpdateCustodianGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCustodianGroupRequest>, I>>(
    object: I,
  ): UpdateCustodianGroupRequest {
    const message = createBaseUpdateCustodianGroupRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.uid = object.uid ?? "";
    message.name = object.name ?? "";
    message.quorum = object.quorum ?? 0;
    message.status = object.status ?? 0;
    message.description = object.description ?? "";
    message.custodian = object.custodian?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateCustodianGroupResponse(): UpdateCustodianGroupResponse {
  return { group: undefined };
}

export const UpdateCustodianGroupResponse = {
  encode(
    message: UpdateCustodianGroupResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.group !== undefined) {
      CustodianGroup.encode(message.group, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): UpdateCustodianGroupResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustodianGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = CustodianGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustodianGroupResponse {
    return {
      group: isSet(object.group)
        ? CustodianGroup.fromJSON(object.group)
        : undefined,
    };
  },

  toJSON(message: UpdateCustodianGroupResponse): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = CustodianGroup.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCustodianGroupResponse>, I>>(
    base?: I,
  ): UpdateCustodianGroupResponse {
    return UpdateCustodianGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCustodianGroupResponse>, I>>(
    object: I,
  ): UpdateCustodianGroupResponse {
    const message = createBaseUpdateCustodianGroupResponse();
    message.group =
      object.group !== undefined && object.group !== null
        ? CustodianGroup.fromPartial(object.group)
        : undefined;
    return message;
  },
};

function createBaseAddCustodianToGroupRequest(): AddCustodianToGroupRequest {
  return {
    sender: new Uint8Array(0),
    guid: "",
    custodianPubkey: new Uint8Array(0),
    description: "",
  };
}

export const AddCustodianToGroupRequest = {
  encode(
    message: AddCustodianToGroupRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.guid !== "") {
      writer.uint32(18).string(message.guid);
    }
    if (message.custodianPubkey.length !== 0) {
      writer.uint32(26).bytes(message.custodianPubkey);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): AddCustodianToGroupRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCustodianToGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.guid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.custodianPubkey = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddCustodianToGroupRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      guid: isSet(object.guid) ? globalThis.String(object.guid) : "",
      custodianPubkey: isSet(object.custodianPubkey)
        ? bytesFromBase64(object.custodianPubkey)
        : new Uint8Array(0),
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
    };
  },

  toJSON(message: AddCustodianToGroupRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.guid !== "") {
      obj.guid = message.guid;
    }
    if (message.custodianPubkey.length !== 0) {
      obj.custodianPubkey = base64FromBytes(message.custodianPubkey);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddCustodianToGroupRequest>, I>>(
    base?: I,
  ): AddCustodianToGroupRequest {
    return AddCustodianToGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddCustodianToGroupRequest>, I>>(
    object: I,
  ): AddCustodianToGroupRequest {
    const message = createBaseAddCustodianToGroupRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.guid = object.guid ?? "";
    message.custodianPubkey = object.custodianPubkey ?? new Uint8Array(0);
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseRemoveCustodianFromGroupRequest(): RemoveCustodianFromGroupRequest {
  return {
    sender: new Uint8Array(0),
    guid: "",
    custodianPubkey: new Uint8Array(0),
    description: "",
  };
}

export const RemoveCustodianFromGroupRequest = {
  encode(
    message: RemoveCustodianFromGroupRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.guid !== "") {
      writer.uint32(18).string(message.guid);
    }
    if (message.custodianPubkey.length !== 0) {
      writer.uint32(26).bytes(message.custodianPubkey);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RemoveCustodianFromGroupRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveCustodianFromGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.guid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.custodianPubkey = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveCustodianFromGroupRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      guid: isSet(object.guid) ? globalThis.String(object.guid) : "",
      custodianPubkey: isSet(object.custodianPubkey)
        ? bytesFromBase64(object.custodianPubkey)
        : new Uint8Array(0),
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
    };
  },

  toJSON(message: RemoveCustodianFromGroupRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.guid !== "") {
      obj.guid = message.guid;
    }
    if (message.custodianPubkey.length !== 0) {
      obj.custodianPubkey = base64FromBytes(message.custodianPubkey);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveCustodianFromGroupRequest>, I>>(
    base?: I,
  ): RemoveCustodianFromGroupRequest {
    return RemoveCustodianFromGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveCustodianFromGroupRequest>, I>>(
    object: I,
  ): RemoveCustodianFromGroupRequest {
    const message = createBaseRemoveCustodianFromGroupRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.guid = object.guid ?? "";
    message.custodianPubkey = object.custodianPubkey ?? new Uint8Array(0);
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCustodianToGroupResponse(): CustodianToGroupResponse {
  return { group: undefined };
}

export const CustodianToGroupResponse = {
  encode(
    message: CustodianToGroupResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.group !== undefined) {
      CustodianGroup.encode(message.group, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CustodianToGroupResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustodianToGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = CustodianGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustodianToGroupResponse {
    return {
      group: isSet(object.group)
        ? CustodianGroup.fromJSON(object.group)
        : undefined,
    };
  },

  toJSON(message: CustodianToGroupResponse): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = CustodianGroup.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustodianToGroupResponse>, I>>(
    base?: I,
  ): CustodianToGroupResponse {
    return CustodianToGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustodianToGroupResponse>, I>>(
    object: I,
  ): CustodianToGroupResponse {
    const message = createBaseCustodianToGroupResponse();
    message.group =
      object.group !== undefined && object.group !== null
        ? CustodianGroup.fromPartial(object.group)
        : undefined;
    return message;
  },
};

function createBaseSubmitTapScriptSigsRequest(): SubmitTapScriptSigsRequest {
  return {
    sender: new Uint8Array(0),
    sigId: Long.UZERO,
    listOfTapScriptSigsMap: [],
  };
}

export const SubmitTapScriptSigsRequest = {
  encode(
    message: SubmitTapScriptSigsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (!message.sigId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.sigId);
    }
    for (const v of message.listOfTapScriptSigsMap) {
      TapScriptSigsMap.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): SubmitTapScriptSigsRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTapScriptSigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sigId = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.listOfTapScriptSigsMap.push(
            TapScriptSigsMap.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTapScriptSigsRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      sigId: isSet(object.sigId) ? Long.fromValue(object.sigId) : Long.UZERO,
      listOfTapScriptSigsMap: globalThis.Array.isArray(
        object?.listOfTapScriptSigsMap,
      )
        ? object.listOfTapScriptSigsMap.map((e: any) =>
            TapScriptSigsMap.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: SubmitTapScriptSigsRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (!message.sigId.equals(Long.UZERO)) {
      obj.sigId = (message.sigId || Long.UZERO).toString();
    }
    if (message.listOfTapScriptSigsMap?.length) {
      obj.listOfTapScriptSigsMap = message.listOfTapScriptSigsMap.map((e) =>
        TapScriptSigsMap.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTapScriptSigsRequest>, I>>(
    base?: I,
  ): SubmitTapScriptSigsRequest {
    return SubmitTapScriptSigsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTapScriptSigsRequest>, I>>(
    object: I,
  ): SubmitTapScriptSigsRequest {
    const message = createBaseSubmitTapScriptSigsRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.sigId =
      object.sigId !== undefined && object.sigId !== null
        ? Long.fromValue(object.sigId)
        : Long.UZERO;
    message.listOfTapScriptSigsMap =
      object.listOfTapScriptSigsMap?.map((e) =>
        TapScriptSigsMap.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseSubmitTapScriptSigsResponse(): SubmitTapScriptSigsResponse {
  return {};
}

export const SubmitTapScriptSigsResponse = {
  encode(
    _: SubmitTapScriptSigsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): SubmitTapScriptSigsResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTapScriptSigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SubmitTapScriptSigsResponse {
    return {};
  },

  toJSON(_: SubmitTapScriptSigsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTapScriptSigsResponse>, I>>(
    base?: I,
  ): SubmitTapScriptSigsResponse {
    return SubmitTapScriptSigsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTapScriptSigsResponse>, I>>(
    _: I,
  ): SubmitTapScriptSigsResponse {
    const message = createBaseSubmitTapScriptSigsResponse();
    return message;
  },
};

function createBaseRotateKeyRequest(): RotateKeyRequest {
  return { sender: new Uint8Array(0), chain: "" };
}

export const RotateKeyRequest = {
  encode(
    message: RotateKeyRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RotateKeyRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RotateKeyRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
    };
  },

  toJSON(message: RotateKeyRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RotateKeyRequest>, I>>(
    base?: I,
  ): RotateKeyRequest {
    return RotateKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RotateKeyRequest>, I>>(
    object: I,
  ): RotateKeyRequest {
    const message = createBaseRotateKeyRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.chain = object.chain ?? "";
    return message;
  },
};

function createBaseRotateKeyResponse(): RotateKeyResponse {
  return {};
}

export const RotateKeyResponse = {
  encode(
    _: RotateKeyResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RotateKeyResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RotateKeyResponse {
    return {};
  },

  toJSON(_: RotateKeyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RotateKeyResponse>, I>>(
    base?: I,
  ): RotateKeyResponse {
    return RotateKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RotateKeyResponse>, I>>(
    _: I,
  ): RotateKeyResponse {
    const message = createBaseRotateKeyResponse();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
