// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.3
// source: scalar/covenant/v1beta1/tx.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import {
  Custodian,
  CustodianGroup,
  Status,
  statusFromJSON,
  statusToJSON,
} from "../exported/v1beta1/custodian";
import { TapScriptSigsMap } from "../exported/v1beta1/types";

export const protobufPackage = "scalar.covenant.v1beta1";

export interface CreateCustodianRequest {
  sender: Uint8Array;
  name: string;
  bitcoinPubkey: Uint8Array;
  status: Status;
  description: string;
}

export interface CreateCustodianResponse {
  custodian?: Custodian | undefined;
}

/** Pubkey used as key for lookup custodian to update other values */
export interface UpdateCustodianRequest {
  sender: Uint8Array;
  bitcoinPubkey: Uint8Array;
  name: string;
  status: Status;
  description: string;
}

export interface UpdateCustodianResponse {
  custodian?: Custodian | undefined;
}

export interface CreateCustodianGroupRequest {
  sender: Uint8Array;
  uid: string;
  name: string;
  quorum: number;
  status: Status;
  description: string;
  custodian: Uint8Array[];
}

export interface CreateCustodianGroupResponse {
  group?: CustodianGroup | undefined;
}

export interface UpdateCustodianGroupRequest {
  sender: Uint8Array;
  uid: string;
  name: string;
  quorum: number;
  status: Status;
  description: string;
  custodian: Uint8Array[];
}

export interface UpdateCustodianGroupResponse {
  group?: CustodianGroup | undefined;
}

export interface AddCustodianToGroupRequest {
  sender: Uint8Array;
  /** CustodianGroup uid */
  guid: string;
  custodianPubkey: Uint8Array;
  description: string;
}

export interface RemoveCustodianFromGroupRequest {
  sender: Uint8Array;
  /** CustodianGroup uid */
  guid: string;
  custodianPubkey: Uint8Array;
  description: string;
}

export interface CustodianToGroupResponse {
  group?: CustodianGroup | undefined;
}

export interface SubmitTapScriptSigsRequest {
  sender: Uint8Array;
  sigId: Long;
  listOfTapScriptSigsMap: TapScriptSigsMap[];
}

export interface SubmitTapScriptSigsResponse {}

/** Rotate key for custodian group */
export interface RotateKeyRequest {
  sender: Uint8Array;
  chain: string;
}

export interface RotateKeyResponse {}

export interface ConfirmSwitchedPhaseRequest {
  sender: Uint8Array;
  chain: string;
  custodianGroupUid: Uint8Array;
  txId: Uint8Array;
}

export interface ConfirmSwitchedPhaseResponse {}

export interface ReserveRedeemUtxoRequest {
  sender: Uint8Array;
  /** User evm address */
  address: string;
  /** Evm chain */
  sourceChain: string;
  /** BTC chain */
  destChain: string;
  /** Token symbol */
  symbol: string;
  /** Redeem amount */
  amount: Long;
  lockingScript: Uint8Array;
}

export interface ReserveRedeemUtxoResponse {}

/** Confirm exectuted transaction on bitcoin */
export interface ConfirmRedeemTxsRequest {
  sender: Uint8Array;
  chain: string;
  txIds: Uint8Array[];
  custodianGroupUid: Uint8Array;
}

export interface ConfirmRedeemTxsResponse {}

export interface InitializeUtxoRequest {
  sender: Uint8Array;
  chain: string;
  /** Current block height sent from the relayer */
  blockCheckpoint: Long;
}

export interface InitializeUtxoResponse {}

function createBaseCreateCustodianRequest(): CreateCustodianRequest {
  return {
    sender: new Uint8Array(0),
    name: "",
    bitcoinPubkey: new Uint8Array(0),
    status: 0,
    description: "",
  };
}

export const CreateCustodianRequest = {
  encode(
    message: CreateCustodianRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.bitcoinPubkey.length !== 0) {
      writer.uint32(26).bytes(message.bitcoinPubkey);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CreateCustodianRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustodianRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bitcoinPubkey = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustodianRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      bitcoinPubkey: isSet(object.bitcoinPubkey)
        ? bytesFromBase64(object.bitcoinPubkey)
        : new Uint8Array(0),
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
    };
  },

  toJSON(message: CreateCustodianRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.bitcoinPubkey.length !== 0) {
      obj.bitcoinPubkey = base64FromBytes(message.bitcoinPubkey);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustodianRequest>, I>>(
    base?: I,
  ): CreateCustodianRequest {
    return CreateCustodianRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustodianRequest>, I>>(
    object: I,
  ): CreateCustodianRequest {
    const message = createBaseCreateCustodianRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.name = object.name ?? "";
    message.bitcoinPubkey = object.bitcoinPubkey ?? new Uint8Array(0);
    message.status = object.status ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCreateCustodianResponse(): CreateCustodianResponse {
  return { custodian: undefined };
}

export const CreateCustodianResponse = {
  encode(
    message: CreateCustodianResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.custodian !== undefined) {
      Custodian.encode(message.custodian, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CreateCustodianResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustodianResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.custodian = Custodian.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustodianResponse {
    return {
      custodian: isSet(object.custodian)
        ? Custodian.fromJSON(object.custodian)
        : undefined,
    };
  },

  toJSON(message: CreateCustodianResponse): unknown {
    const obj: any = {};
    if (message.custodian !== undefined) {
      obj.custodian = Custodian.toJSON(message.custodian);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustodianResponse>, I>>(
    base?: I,
  ): CreateCustodianResponse {
    return CreateCustodianResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustodianResponse>, I>>(
    object: I,
  ): CreateCustodianResponse {
    const message = createBaseCreateCustodianResponse();
    message.custodian =
      object.custodian !== undefined && object.custodian !== null
        ? Custodian.fromPartial(object.custodian)
        : undefined;
    return message;
  },
};

function createBaseUpdateCustodianRequest(): UpdateCustodianRequest {
  return {
    sender: new Uint8Array(0),
    bitcoinPubkey: new Uint8Array(0),
    name: "",
    status: 0,
    description: "",
  };
}

export const UpdateCustodianRequest = {
  encode(
    message: UpdateCustodianRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.bitcoinPubkey.length !== 0) {
      writer.uint32(18).bytes(message.bitcoinPubkey);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): UpdateCustodianRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustodianRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bitcoinPubkey = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustodianRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      bitcoinPubkey: isSet(object.bitcoinPubkey)
        ? bytesFromBase64(object.bitcoinPubkey)
        : new Uint8Array(0),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
    };
  },

  toJSON(message: UpdateCustodianRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.bitcoinPubkey.length !== 0) {
      obj.bitcoinPubkey = base64FromBytes(message.bitcoinPubkey);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCustodianRequest>, I>>(
    base?: I,
  ): UpdateCustodianRequest {
    return UpdateCustodianRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCustodianRequest>, I>>(
    object: I,
  ): UpdateCustodianRequest {
    const message = createBaseUpdateCustodianRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.bitcoinPubkey = object.bitcoinPubkey ?? new Uint8Array(0);
    message.name = object.name ?? "";
    message.status = object.status ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseUpdateCustodianResponse(): UpdateCustodianResponse {
  return { custodian: undefined };
}

export const UpdateCustodianResponse = {
  encode(
    message: UpdateCustodianResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.custodian !== undefined) {
      Custodian.encode(message.custodian, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): UpdateCustodianResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustodianResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.custodian = Custodian.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustodianResponse {
    return {
      custodian: isSet(object.custodian)
        ? Custodian.fromJSON(object.custodian)
        : undefined,
    };
  },

  toJSON(message: UpdateCustodianResponse): unknown {
    const obj: any = {};
    if (message.custodian !== undefined) {
      obj.custodian = Custodian.toJSON(message.custodian);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCustodianResponse>, I>>(
    base?: I,
  ): UpdateCustodianResponse {
    return UpdateCustodianResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCustodianResponse>, I>>(
    object: I,
  ): UpdateCustodianResponse {
    const message = createBaseUpdateCustodianResponse();
    message.custodian =
      object.custodian !== undefined && object.custodian !== null
        ? Custodian.fromPartial(object.custodian)
        : undefined;
    return message;
  },
};

function createBaseCreateCustodianGroupRequest(): CreateCustodianGroupRequest {
  return {
    sender: new Uint8Array(0),
    uid: "",
    name: "",
    quorum: 0,
    status: 0,
    description: "",
    custodian: [],
  };
}

export const CreateCustodianGroupRequest = {
  encode(
    message: CreateCustodianGroupRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.quorum !== 0) {
      writer.uint32(32).uint32(message.quorum);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    for (const v of message.custodian) {
      writer.uint32(58).bytes(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CreateCustodianGroupRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustodianGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quorum = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.custodian.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustodianGroupRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      quorum: isSet(object.quorum) ? globalThis.Number(object.quorum) : 0,
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      custodian: globalThis.Array.isArray(object?.custodian)
        ? object.custodian.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: CreateCustodianGroupRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.quorum !== 0) {
      obj.quorum = Math.round(message.quorum);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.custodian?.length) {
      obj.custodian = message.custodian.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustodianGroupRequest>, I>>(
    base?: I,
  ): CreateCustodianGroupRequest {
    return CreateCustodianGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustodianGroupRequest>, I>>(
    object: I,
  ): CreateCustodianGroupRequest {
    const message = createBaseCreateCustodianGroupRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.uid = object.uid ?? "";
    message.name = object.name ?? "";
    message.quorum = object.quorum ?? 0;
    message.status = object.status ?? 0;
    message.description = object.description ?? "";
    message.custodian = object.custodian?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateCustodianGroupResponse(): CreateCustodianGroupResponse {
  return { group: undefined };
}

export const CreateCustodianGroupResponse = {
  encode(
    message: CreateCustodianGroupResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.group !== undefined) {
      CustodianGroup.encode(message.group, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CreateCustodianGroupResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustodianGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = CustodianGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustodianGroupResponse {
    return {
      group: isSet(object.group)
        ? CustodianGroup.fromJSON(object.group)
        : undefined,
    };
  },

  toJSON(message: CreateCustodianGroupResponse): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = CustodianGroup.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCustodianGroupResponse>, I>>(
    base?: I,
  ): CreateCustodianGroupResponse {
    return CreateCustodianGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCustodianGroupResponse>, I>>(
    object: I,
  ): CreateCustodianGroupResponse {
    const message = createBaseCreateCustodianGroupResponse();
    message.group =
      object.group !== undefined && object.group !== null
        ? CustodianGroup.fromPartial(object.group)
        : undefined;
    return message;
  },
};

function createBaseUpdateCustodianGroupRequest(): UpdateCustodianGroupRequest {
  return {
    sender: new Uint8Array(0),
    uid: "",
    name: "",
    quorum: 0,
    status: 0,
    description: "",
    custodian: [],
  };
}

export const UpdateCustodianGroupRequest = {
  encode(
    message: UpdateCustodianGroupRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.quorum !== 0) {
      writer.uint32(32).uint32(message.quorum);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    for (const v of message.custodian) {
      writer.uint32(58).bytes(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): UpdateCustodianGroupRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustodianGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quorum = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.custodian.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustodianGroupRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      quorum: isSet(object.quorum) ? globalThis.Number(object.quorum) : 0,
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      custodian: globalThis.Array.isArray(object?.custodian)
        ? object.custodian.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: UpdateCustodianGroupRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.quorum !== 0) {
      obj.quorum = Math.round(message.quorum);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.custodian?.length) {
      obj.custodian = message.custodian.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCustodianGroupRequest>, I>>(
    base?: I,
  ): UpdateCustodianGroupRequest {
    return UpdateCustodianGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCustodianGroupRequest>, I>>(
    object: I,
  ): UpdateCustodianGroupRequest {
    const message = createBaseUpdateCustodianGroupRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.uid = object.uid ?? "";
    message.name = object.name ?? "";
    message.quorum = object.quorum ?? 0;
    message.status = object.status ?? 0;
    message.description = object.description ?? "";
    message.custodian = object.custodian?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateCustodianGroupResponse(): UpdateCustodianGroupResponse {
  return { group: undefined };
}

export const UpdateCustodianGroupResponse = {
  encode(
    message: UpdateCustodianGroupResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.group !== undefined) {
      CustodianGroup.encode(message.group, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): UpdateCustodianGroupResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustodianGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = CustodianGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustodianGroupResponse {
    return {
      group: isSet(object.group)
        ? CustodianGroup.fromJSON(object.group)
        : undefined,
    };
  },

  toJSON(message: UpdateCustodianGroupResponse): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = CustodianGroup.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCustodianGroupResponse>, I>>(
    base?: I,
  ): UpdateCustodianGroupResponse {
    return UpdateCustodianGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCustodianGroupResponse>, I>>(
    object: I,
  ): UpdateCustodianGroupResponse {
    const message = createBaseUpdateCustodianGroupResponse();
    message.group =
      object.group !== undefined && object.group !== null
        ? CustodianGroup.fromPartial(object.group)
        : undefined;
    return message;
  },
};

function createBaseAddCustodianToGroupRequest(): AddCustodianToGroupRequest {
  return {
    sender: new Uint8Array(0),
    guid: "",
    custodianPubkey: new Uint8Array(0),
    description: "",
  };
}

export const AddCustodianToGroupRequest = {
  encode(
    message: AddCustodianToGroupRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.guid !== "") {
      writer.uint32(18).string(message.guid);
    }
    if (message.custodianPubkey.length !== 0) {
      writer.uint32(26).bytes(message.custodianPubkey);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): AddCustodianToGroupRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCustodianToGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.guid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.custodianPubkey = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddCustodianToGroupRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      guid: isSet(object.guid) ? globalThis.String(object.guid) : "",
      custodianPubkey: isSet(object.custodianPubkey)
        ? bytesFromBase64(object.custodianPubkey)
        : new Uint8Array(0),
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
    };
  },

  toJSON(message: AddCustodianToGroupRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.guid !== "") {
      obj.guid = message.guid;
    }
    if (message.custodianPubkey.length !== 0) {
      obj.custodianPubkey = base64FromBytes(message.custodianPubkey);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddCustodianToGroupRequest>, I>>(
    base?: I,
  ): AddCustodianToGroupRequest {
    return AddCustodianToGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddCustodianToGroupRequest>, I>>(
    object: I,
  ): AddCustodianToGroupRequest {
    const message = createBaseAddCustodianToGroupRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.guid = object.guid ?? "";
    message.custodianPubkey = object.custodianPubkey ?? new Uint8Array(0);
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseRemoveCustodianFromGroupRequest(): RemoveCustodianFromGroupRequest {
  return {
    sender: new Uint8Array(0),
    guid: "",
    custodianPubkey: new Uint8Array(0),
    description: "",
  };
}

export const RemoveCustodianFromGroupRequest = {
  encode(
    message: RemoveCustodianFromGroupRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.guid !== "") {
      writer.uint32(18).string(message.guid);
    }
    if (message.custodianPubkey.length !== 0) {
      writer.uint32(26).bytes(message.custodianPubkey);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RemoveCustodianFromGroupRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveCustodianFromGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.guid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.custodianPubkey = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveCustodianFromGroupRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      guid: isSet(object.guid) ? globalThis.String(object.guid) : "",
      custodianPubkey: isSet(object.custodianPubkey)
        ? bytesFromBase64(object.custodianPubkey)
        : new Uint8Array(0),
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
    };
  },

  toJSON(message: RemoveCustodianFromGroupRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.guid !== "") {
      obj.guid = message.guid;
    }
    if (message.custodianPubkey.length !== 0) {
      obj.custodianPubkey = base64FromBytes(message.custodianPubkey);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveCustodianFromGroupRequest>, I>>(
    base?: I,
  ): RemoveCustodianFromGroupRequest {
    return RemoveCustodianFromGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveCustodianFromGroupRequest>, I>>(
    object: I,
  ): RemoveCustodianFromGroupRequest {
    const message = createBaseRemoveCustodianFromGroupRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.guid = object.guid ?? "";
    message.custodianPubkey = object.custodianPubkey ?? new Uint8Array(0);
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCustodianToGroupResponse(): CustodianToGroupResponse {
  return { group: undefined };
}

export const CustodianToGroupResponse = {
  encode(
    message: CustodianToGroupResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.group !== undefined) {
      CustodianGroup.encode(message.group, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): CustodianToGroupResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustodianToGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = CustodianGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustodianToGroupResponse {
    return {
      group: isSet(object.group)
        ? CustodianGroup.fromJSON(object.group)
        : undefined,
    };
  },

  toJSON(message: CustodianToGroupResponse): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = CustodianGroup.toJSON(message.group);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustodianToGroupResponse>, I>>(
    base?: I,
  ): CustodianToGroupResponse {
    return CustodianToGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustodianToGroupResponse>, I>>(
    object: I,
  ): CustodianToGroupResponse {
    const message = createBaseCustodianToGroupResponse();
    message.group =
      object.group !== undefined && object.group !== null
        ? CustodianGroup.fromPartial(object.group)
        : undefined;
    return message;
  },
};

function createBaseSubmitTapScriptSigsRequest(): SubmitTapScriptSigsRequest {
  return {
    sender: new Uint8Array(0),
    sigId: Long.UZERO,
    listOfTapScriptSigsMap: [],
  };
}

export const SubmitTapScriptSigsRequest = {
  encode(
    message: SubmitTapScriptSigsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (!message.sigId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.sigId);
    }
    for (const v of message.listOfTapScriptSigsMap) {
      TapScriptSigsMap.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): SubmitTapScriptSigsRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTapScriptSigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sigId = reader.uint64() as Long;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.listOfTapScriptSigsMap.push(
            TapScriptSigsMap.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTapScriptSigsRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      sigId: isSet(object.sigId) ? Long.fromValue(object.sigId) : Long.UZERO,
      listOfTapScriptSigsMap: globalThis.Array.isArray(
        object?.listOfTapScriptSigsMap,
      )
        ? object.listOfTapScriptSigsMap.map((e: any) =>
            TapScriptSigsMap.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: SubmitTapScriptSigsRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (!message.sigId.equals(Long.UZERO)) {
      obj.sigId = (message.sigId || Long.UZERO).toString();
    }
    if (message.listOfTapScriptSigsMap?.length) {
      obj.listOfTapScriptSigsMap = message.listOfTapScriptSigsMap.map((e) =>
        TapScriptSigsMap.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTapScriptSigsRequest>, I>>(
    base?: I,
  ): SubmitTapScriptSigsRequest {
    return SubmitTapScriptSigsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTapScriptSigsRequest>, I>>(
    object: I,
  ): SubmitTapScriptSigsRequest {
    const message = createBaseSubmitTapScriptSigsRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.sigId =
      object.sigId !== undefined && object.sigId !== null
        ? Long.fromValue(object.sigId)
        : Long.UZERO;
    message.listOfTapScriptSigsMap =
      object.listOfTapScriptSigsMap?.map((e) =>
        TapScriptSigsMap.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseSubmitTapScriptSigsResponse(): SubmitTapScriptSigsResponse {
  return {};
}

export const SubmitTapScriptSigsResponse = {
  encode(
    _: SubmitTapScriptSigsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): SubmitTapScriptSigsResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTapScriptSigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SubmitTapScriptSigsResponse {
    return {};
  },

  toJSON(_: SubmitTapScriptSigsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTapScriptSigsResponse>, I>>(
    base?: I,
  ): SubmitTapScriptSigsResponse {
    return SubmitTapScriptSigsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTapScriptSigsResponse>, I>>(
    _: I,
  ): SubmitTapScriptSigsResponse {
    const message = createBaseSubmitTapScriptSigsResponse();
    return message;
  },
};

function createBaseRotateKeyRequest(): RotateKeyRequest {
  return { sender: new Uint8Array(0), chain: "" };
}

export const RotateKeyRequest = {
  encode(
    message: RotateKeyRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RotateKeyRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RotateKeyRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
    };
  },

  toJSON(message: RotateKeyRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RotateKeyRequest>, I>>(
    base?: I,
  ): RotateKeyRequest {
    return RotateKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RotateKeyRequest>, I>>(
    object: I,
  ): RotateKeyRequest {
    const message = createBaseRotateKeyRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.chain = object.chain ?? "";
    return message;
  },
};

function createBaseRotateKeyResponse(): RotateKeyResponse {
  return {};
}

export const RotateKeyResponse = {
  encode(
    _: RotateKeyResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RotateKeyResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRotateKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RotateKeyResponse {
    return {};
  },

  toJSON(_: RotateKeyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RotateKeyResponse>, I>>(
    base?: I,
  ): RotateKeyResponse {
    return RotateKeyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RotateKeyResponse>, I>>(
    _: I,
  ): RotateKeyResponse {
    const message = createBaseRotateKeyResponse();
    return message;
  },
};

function createBaseConfirmSwitchedPhaseRequest(): ConfirmSwitchedPhaseRequest {
  return {
    sender: new Uint8Array(0),
    chain: "",
    custodianGroupUid: new Uint8Array(0),
    txId: new Uint8Array(0),
  };
}

export const ConfirmSwitchedPhaseRequest = {
  encode(
    message: ConfirmSwitchedPhaseRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (message.custodianGroupUid.length !== 0) {
      writer.uint32(26).bytes(message.custodianGroupUid);
    }
    if (message.txId.length !== 0) {
      writer.uint32(34).bytes(message.txId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ConfirmSwitchedPhaseRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmSwitchedPhaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.custodianGroupUid = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.txId = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmSwitchedPhaseRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      custodianGroupUid: isSet(object.custodianGroupUid)
        ? bytesFromBase64(object.custodianGroupUid)
        : new Uint8Array(0),
      txId: isSet(object.txId)
        ? bytesFromBase64(object.txId)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ConfirmSwitchedPhaseRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.custodianGroupUid.length !== 0) {
      obj.custodianGroupUid = base64FromBytes(message.custodianGroupUid);
    }
    if (message.txId.length !== 0) {
      obj.txId = base64FromBytes(message.txId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmSwitchedPhaseRequest>, I>>(
    base?: I,
  ): ConfirmSwitchedPhaseRequest {
    return ConfirmSwitchedPhaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmSwitchedPhaseRequest>, I>>(
    object: I,
  ): ConfirmSwitchedPhaseRequest {
    const message = createBaseConfirmSwitchedPhaseRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.chain = object.chain ?? "";
    message.custodianGroupUid = object.custodianGroupUid ?? new Uint8Array(0);
    message.txId = object.txId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseConfirmSwitchedPhaseResponse(): ConfirmSwitchedPhaseResponse {
  return {};
}

export const ConfirmSwitchedPhaseResponse = {
  encode(
    _: ConfirmSwitchedPhaseResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ConfirmSwitchedPhaseResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmSwitchedPhaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConfirmSwitchedPhaseResponse {
    return {};
  },

  toJSON(_: ConfirmSwitchedPhaseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmSwitchedPhaseResponse>, I>>(
    base?: I,
  ): ConfirmSwitchedPhaseResponse {
    return ConfirmSwitchedPhaseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmSwitchedPhaseResponse>, I>>(
    _: I,
  ): ConfirmSwitchedPhaseResponse {
    const message = createBaseConfirmSwitchedPhaseResponse();
    return message;
  },
};

function createBaseReserveRedeemUtxoRequest(): ReserveRedeemUtxoRequest {
  return {
    sender: new Uint8Array(0),
    address: "",
    sourceChain: "",
    destChain: "",
    symbol: "",
    amount: Long.UZERO,
    lockingScript: new Uint8Array(0),
  };
}

export const ReserveRedeemUtxoRequest = {
  encode(
    message: ReserveRedeemUtxoRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.sourceChain !== "") {
      writer.uint32(26).string(message.sourceChain);
    }
    if (message.destChain !== "") {
      writer.uint32(34).string(message.destChain);
    }
    if (message.symbol !== "") {
      writer.uint32(42).string(message.symbol);
    }
    if (!message.amount.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.amount);
    }
    if (message.lockingScript.length !== 0) {
      writer.uint32(58).bytes(message.lockingScript);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ReserveRedeemUtxoRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveRedeemUtxoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceChain = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destChain = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.amount = reader.uint64() as Long;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lockingScript = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReserveRedeemUtxoRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      sourceChain: isSet(object.sourceChain)
        ? globalThis.String(object.sourceChain)
        : "",
      destChain: isSet(object.destChain)
        ? globalThis.String(object.destChain)
        : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.UZERO,
      lockingScript: isSet(object.lockingScript)
        ? bytesFromBase64(object.lockingScript)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ReserveRedeemUtxoRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.sourceChain !== "") {
      obj.sourceChain = message.sourceChain;
    }
    if (message.destChain !== "") {
      obj.destChain = message.destChain;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (!message.amount.equals(Long.UZERO)) {
      obj.amount = (message.amount || Long.UZERO).toString();
    }
    if (message.lockingScript.length !== 0) {
      obj.lockingScript = base64FromBytes(message.lockingScript);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReserveRedeemUtxoRequest>, I>>(
    base?: I,
  ): ReserveRedeemUtxoRequest {
    return ReserveRedeemUtxoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReserveRedeemUtxoRequest>, I>>(
    object: I,
  ): ReserveRedeemUtxoRequest {
    const message = createBaseReserveRedeemUtxoRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.address = object.address ?? "";
    message.sourceChain = object.sourceChain ?? "";
    message.destChain = object.destChain ?? "";
    message.symbol = object.symbol ?? "";
    message.amount =
      object.amount !== undefined && object.amount !== null
        ? Long.fromValue(object.amount)
        : Long.UZERO;
    message.lockingScript = object.lockingScript ?? new Uint8Array(0);
    return message;
  },
};

function createBaseReserveRedeemUtxoResponse(): ReserveRedeemUtxoResponse {
  return {};
}

export const ReserveRedeemUtxoResponse = {
  encode(
    _: ReserveRedeemUtxoResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ReserveRedeemUtxoResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveRedeemUtxoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ReserveRedeemUtxoResponse {
    return {};
  },

  toJSON(_: ReserveRedeemUtxoResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ReserveRedeemUtxoResponse>, I>>(
    base?: I,
  ): ReserveRedeemUtxoResponse {
    return ReserveRedeemUtxoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReserveRedeemUtxoResponse>, I>>(
    _: I,
  ): ReserveRedeemUtxoResponse {
    const message = createBaseReserveRedeemUtxoResponse();
    return message;
  },
};

function createBaseConfirmRedeemTxsRequest(): ConfirmRedeemTxsRequest {
  return {
    sender: new Uint8Array(0),
    chain: "",
    txIds: [],
    custodianGroupUid: new Uint8Array(0),
  };
}

export const ConfirmRedeemTxsRequest = {
  encode(
    message: ConfirmRedeemTxsRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    for (const v of message.txIds) {
      writer.uint32(26).bytes(v!);
    }
    if (message.custodianGroupUid.length !== 0) {
      writer.uint32(34).bytes(message.custodianGroupUid);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ConfirmRedeemTxsRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmRedeemTxsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txIds.push(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.custodianGroupUid = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmRedeemTxsRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      txIds: globalThis.Array.isArray(object?.txIds)
        ? object.txIds.map((e: any) => bytesFromBase64(e))
        : [],
      custodianGroupUid: isSet(object.custodianGroupUid)
        ? bytesFromBase64(object.custodianGroupUid)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ConfirmRedeemTxsRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (message.txIds?.length) {
      obj.txIds = message.txIds.map((e) => base64FromBytes(e));
    }
    if (message.custodianGroupUid.length !== 0) {
      obj.custodianGroupUid = base64FromBytes(message.custodianGroupUid);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmRedeemTxsRequest>, I>>(
    base?: I,
  ): ConfirmRedeemTxsRequest {
    return ConfirmRedeemTxsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmRedeemTxsRequest>, I>>(
    object: I,
  ): ConfirmRedeemTxsRequest {
    const message = createBaseConfirmRedeemTxsRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.chain = object.chain ?? "";
    message.txIds = object.txIds?.map((e) => e) || [];
    message.custodianGroupUid = object.custodianGroupUid ?? new Uint8Array(0);
    return message;
  },
};

function createBaseConfirmRedeemTxsResponse(): ConfirmRedeemTxsResponse {
  return {};
}

export const ConfirmRedeemTxsResponse = {
  encode(
    _: ConfirmRedeemTxsResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ConfirmRedeemTxsResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmRedeemTxsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ConfirmRedeemTxsResponse {
    return {};
  },

  toJSON(_: ConfirmRedeemTxsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmRedeemTxsResponse>, I>>(
    base?: I,
  ): ConfirmRedeemTxsResponse {
    return ConfirmRedeemTxsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmRedeemTxsResponse>, I>>(
    _: I,
  ): ConfirmRedeemTxsResponse {
    const message = createBaseConfirmRedeemTxsResponse();
    return message;
  },
};

function createBaseInitializeUtxoRequest(): InitializeUtxoRequest {
  return { sender: new Uint8Array(0), chain: "", blockCheckpoint: Long.UZERO };
}

export const InitializeUtxoRequest = {
  encode(
    message: InitializeUtxoRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sender.length !== 0) {
      writer.uint32(10).bytes(message.sender);
    }
    if (message.chain !== "") {
      writer.uint32(18).string(message.chain);
    }
    if (!message.blockCheckpoint.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.blockCheckpoint);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): InitializeUtxoRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializeUtxoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chain = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockCheckpoint = reader.uint64() as Long;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitializeUtxoRequest {
    return {
      sender: isSet(object.sender)
        ? bytesFromBase64(object.sender)
        : new Uint8Array(0),
      chain: isSet(object.chain) ? globalThis.String(object.chain) : "",
      blockCheckpoint: isSet(object.blockCheckpoint)
        ? Long.fromValue(object.blockCheckpoint)
        : Long.UZERO,
    };
  },

  toJSON(message: InitializeUtxoRequest): unknown {
    const obj: any = {};
    if (message.sender.length !== 0) {
      obj.sender = base64FromBytes(message.sender);
    }
    if (message.chain !== "") {
      obj.chain = message.chain;
    }
    if (!message.blockCheckpoint.equals(Long.UZERO)) {
      obj.blockCheckpoint = (message.blockCheckpoint || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitializeUtxoRequest>, I>>(
    base?: I,
  ): InitializeUtxoRequest {
    return InitializeUtxoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitializeUtxoRequest>, I>>(
    object: I,
  ): InitializeUtxoRequest {
    const message = createBaseInitializeUtxoRequest();
    message.sender = object.sender ?? new Uint8Array(0);
    message.chain = object.chain ?? "";
    message.blockCheckpoint =
      object.blockCheckpoint !== undefined && object.blockCheckpoint !== null
        ? Long.fromValue(object.blockCheckpoint)
        : Long.UZERO;
    return message;
  },
};

function createBaseInitializeUtxoResponse(): InitializeUtxoResponse {
  return {};
}

export const InitializeUtxoResponse = {
  encode(
    _: InitializeUtxoResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): InitializeUtxoResponse {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializeUtxoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InitializeUtxoResponse {
    return {};
  },

  toJSON(_: InitializeUtxoResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<InitializeUtxoResponse>, I>>(
    base?: I,
  ): InitializeUtxoResponse {
    return InitializeUtxoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitializeUtxoResponse>, I>>(
    _: I,
  ): InitializeUtxoResponse {
    const message = createBaseInitializeUtxoResponse();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Long
    ? string | number | Long
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
