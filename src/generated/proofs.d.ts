// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "proofs.proto" (package "ics23", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * *
 * ExistenceProof takes a key and a value and a set of steps to perform on it.
 * The result of peforming all these steps will provide a "root hash", which can
 * be compared to the value in a header.
 *
 * Since it is computationally infeasible to produce a hash collission for any of the used
 * cryptographic hash functions, if someone can provide a series of operations to transform
 * a given key and value into a root hash that matches some trusted root, these key and values
 * must be in the referenced merkle tree.
 *
 * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
 * which should be controlled by a spec. Eg. with lengthOp as NONE,
 * prefix = FOO, key = BAR, value = CHOICE
 * and
 * prefix = F, key = OOBAR, value = CHOICE
 * would produce the same value.
 *
 * With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
 * in the ProofSpec is valuable to prevent this mutability. And why all trees should
 * length-prefix the data before hashing it.
 *
 * @generated from protobuf message ics23.ExistenceProof
 */
export interface ExistenceProof {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 2;
     */
    value: Uint8Array;
    /**
     * @generated from protobuf field: ics23.LeafOp leaf = 3;
     */
    leaf?: LeafOp;
    /**
     * @generated from protobuf field: repeated ics23.InnerOp path = 4;
     */
    path: InnerOp[];
}
/**
 *
 * NonExistenceProof takes a proof of two neighbors, one left of the desired key,
 * one right of the desired key. If both proofs are valid AND they are neighbors,
 * then there is no valid proof for the given key.
 *
 * @generated from protobuf message ics23.NonExistenceProof
 */
export interface NonExistenceProof {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: ics23.ExistenceProof left = 2;
     */
    left?: ExistenceProof;
    /**
     * @generated from protobuf field: ics23.ExistenceProof right = 3;
     */
    right?: ExistenceProof;
}
/**
 *
 * CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
 *
 * @generated from protobuf message ics23.CommitmentProof
 */
export interface CommitmentProof {
    /**
     * @generated from protobuf oneof: proof
     */
    proof: {
        oneofKind: "exist";
        /**
         * @generated from protobuf field: ics23.ExistenceProof exist = 1;
         */
        exist: ExistenceProof;
    } | {
        oneofKind: "nonexist";
        /**
         * @generated from protobuf field: ics23.NonExistenceProof nonexist = 2;
         */
        nonexist: NonExistenceProof;
    } | {
        oneofKind: "batch";
        /**
         * @generated from protobuf field: ics23.BatchProof batch = 3;
         */
        batch: BatchProof;
    } | {
        oneofKind: "compressed";
        /**
         * @generated from protobuf field: ics23.CompressedBatchProof compressed = 4;
         */
        compressed: CompressedBatchProof;
    } | {
        oneofKind: undefined;
    };
}
/**
 * *
 * LeafOp represents the raw key-value data we wish to prove, and
 * must be flexible to represent the internal transformation from
 * the original key-value pairs into the basis hash, for many existing
 * merkle trees.
 *
 * key and value are passed in. So that the signature of this operation is:
 * leafOp(key, value) -> output
 *
 * To process this, first prehash the keys and values if needed (ANY means no hash in this case):
 * hkey = prehashKey(key)
 * hvalue = prehashValue(value)
 *
 * Then combine the bytes, and hash it
 * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
 *
 * @generated from protobuf message ics23.LeafOp
 */
export interface LeafOp {
    /**
     * @generated from protobuf field: ics23.HashOp hash = 1;
     */
    hash: HashOp;
    /**
     * @generated from protobuf field: ics23.HashOp prehash_key = 2;
     */
    prehashKey: HashOp;
    /**
     * @generated from protobuf field: ics23.HashOp prehash_value = 3;
     */
    prehashValue: HashOp;
    /**
     * @generated from protobuf field: ics23.LengthOp length = 4;
     */
    length: LengthOp;
    /**
     * prefix is a fixed bytes that may optionally be included at the beginning to differentiate
     * a leaf node from an inner node.
     *
     * @generated from protobuf field: bytes prefix = 5;
     */
    prefix: Uint8Array;
}
/**
 * *
 * InnerOp represents a merkle-proof step that is not a leaf.
 * It represents concatenating two children and hashing them to provide the next result.
 *
 * The result of the previous step is passed in, so the signature of this op is:
 * innerOp(child) -> output
 *
 * The result of applying InnerOp should be:
 * output = op.hash(op.prefix || child || op.suffix)
 *
 * where the || operator is concatenation of binary data,
 * and child is the result of hashing all the tree below this step.
 *
 * Any special data, like prepending child with the length, or prepending the entire operation with
 * some value to differentiate from leaf nodes, should be included in prefix and suffix.
 * If either of prefix or suffix is empty, we just treat it as an empty string
 *
 * @generated from protobuf message ics23.InnerOp
 */
export interface InnerOp {
    /**
     * @generated from protobuf field: ics23.HashOp hash = 1;
     */
    hash: HashOp;
    /**
     * @generated from protobuf field: bytes prefix = 2;
     */
    prefix: Uint8Array;
    /**
     * @generated from protobuf field: bytes suffix = 3;
     */
    suffix: Uint8Array;
}
/**
 * *
 * ProofSpec defines what the expected parameters are for a given proof type.
 * This can be stored in the client and used to validate any incoming proofs.
 *
 * verify(ProofSpec, Proof) -> Proof | Error
 *
 * As demonstrated in tests, if we don't fix the algorithm used to calculate the
 * LeafHash for a given tree, there are many possible key-value pairs that can
 * generate a given hash (by interpretting the preimage differently).
 * We need this for proper security, requires client knows a priori what
 * tree format server uses. But not in code, rather a configuration object.
 *
 * @generated from protobuf message ics23.ProofSpec
 */
export interface ProofSpec {
    /**
     * any field in the ExistenceProof must be the same as in this spec.
     * except Prefix, which is just the first bytes of prefix (spec can be longer)
     *
     * @generated from protobuf field: ics23.LeafOp leaf_spec = 1;
     */
    leafSpec?: LeafOp;
    /**
     * @generated from protobuf field: ics23.InnerSpec inner_spec = 2;
     */
    innerSpec?: InnerSpec;
    /**
     * max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
     *
     * @generated from protobuf field: int32 max_depth = 3;
     */
    maxDepth: number;
    /**
     * min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
     *
     * @generated from protobuf field: int32 min_depth = 4;
     */
    minDepth: number;
}
/**
 *
 * InnerSpec contains all store-specific structure info to determine if two proofs from a
 * given store are neighbors.
 *
 * This enables:
 *
 * isLeftMost(spec: InnerSpec, op: InnerOp)
 * isRightMost(spec: InnerSpec, op: InnerOp)
 * isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
 *
 * @generated from protobuf message ics23.InnerSpec
 */
export interface InnerSpec {
    /**
     * Child order is the ordering of the children node, must count from 0
     * iavl tree is [0, 1] (left then right)
     * merk is [0, 2, 1] (left, right, here)
     *
     * @generated from protobuf field: repeated int32 child_order = 1;
     */
    childOrder: number[];
    /**
     * @generated from protobuf field: int32 child_size = 2;
     */
    childSize: number;
    /**
     * @generated from protobuf field: int32 min_prefix_length = 3;
     */
    minPrefixLength: number;
    /**
     * @generated from protobuf field: int32 max_prefix_length = 4;
     */
    maxPrefixLength: number;
    /**
     * empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
     *
     * @generated from protobuf field: bytes empty_child = 5;
     */
    emptyChild: Uint8Array;
    /**
     * hash is the algorithm that must be used for each InnerOp
     *
     * @generated from protobuf field: ics23.HashOp hash = 6;
     */
    hash: HashOp;
}
/**
 *
 * BatchProof is a group of multiple proof types than can be compressed
 *
 * @generated from protobuf message ics23.BatchProof
 */
export interface BatchProof {
    /**
     * @generated from protobuf field: repeated ics23.BatchEntry entries = 1;
     */
    entries: BatchEntry[];
}
/**
 * Use BatchEntry not CommitmentProof, to avoid recursion
 *
 * @generated from protobuf message ics23.BatchEntry
 */
export interface BatchEntry {
    /**
     * @generated from protobuf oneof: proof
     */
    proof: {
        oneofKind: "exist";
        /**
         * @generated from protobuf field: ics23.ExistenceProof exist = 1;
         */
        exist: ExistenceProof;
    } | {
        oneofKind: "nonexist";
        /**
         * @generated from protobuf field: ics23.NonExistenceProof nonexist = 2;
         */
        nonexist: NonExistenceProof;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message ics23.CompressedBatchProof
 */
export interface CompressedBatchProof {
    /**
     * @generated from protobuf field: repeated ics23.CompressedBatchEntry entries = 1;
     */
    entries: CompressedBatchEntry[];
    /**
     * @generated from protobuf field: repeated ics23.InnerOp lookup_inners = 2;
     */
    lookupInners: InnerOp[];
}
/**
 * Use BatchEntry not CommitmentProof, to avoid recursion
 *
 * @generated from protobuf message ics23.CompressedBatchEntry
 */
export interface CompressedBatchEntry {
    /**
     * @generated from protobuf oneof: proof
     */
    proof: {
        oneofKind: "exist";
        /**
         * @generated from protobuf field: ics23.CompressedExistenceProof exist = 1;
         */
        exist: CompressedExistenceProof;
    } | {
        oneofKind: "nonexist";
        /**
         * @generated from protobuf field: ics23.CompressedNonExistenceProof nonexist = 2;
         */
        nonexist: CompressedNonExistenceProof;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message ics23.CompressedExistenceProof
 */
export interface CompressedExistenceProof {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes value = 2;
     */
    value: Uint8Array;
    /**
     * @generated from protobuf field: ics23.LeafOp leaf = 3;
     */
    leaf?: LeafOp;
    /**
     * these are indexes into the lookup_inners table in CompressedBatchProof
     *
     * @generated from protobuf field: repeated int32 path = 4;
     */
    path: number[];
}
/**
 * @generated from protobuf message ics23.CompressedNonExistenceProof
 */
export interface CompressedNonExistenceProof {
    /**
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: ics23.CompressedExistenceProof left = 2;
     */
    left?: CompressedExistenceProof;
    /**
     * @generated from protobuf field: ics23.CompressedExistenceProof right = 3;
     */
    right?: CompressedExistenceProof;
}
/**
 * @generated from protobuf enum ics23.HashOp
 */
export declare enum HashOp {
    /**
     * NO_HASH is the default if no data passed. Note this is an illegal argument some places.
     *
     * @generated from protobuf enum value: NO_HASH = 0;
     */
    NO_HASH = 0,
    /**
     * @generated from protobuf enum value: SHA256 = 1;
     */
    SHA256 = 1,
    /**
     * @generated from protobuf enum value: SHA512 = 2;
     */
    SHA512 = 2,
    /**
     * @generated from protobuf enum value: KECCAK = 3;
     */
    KECCAK = 3,
    /**
     * @generated from protobuf enum value: RIPEMD160 = 4;
     */
    RIPEMD160 = 4,
    /**
     * ripemd160(sha256(x))
     *
     * @generated from protobuf enum value: BITCOIN = 5;
     */
    BITCOIN = 5,
    /**
     * @generated from protobuf enum value: SHA512_256 = 6;
     */
    SHA512_256 = 6
}
/**
 * *
 * LengthOp defines how to process the key and value of the LeafOp
 * to include length information. After encoding the length with the given
 * algorithm, the length will be prepended to the key and value bytes.
 * (Each one with it's own encoded length)
 *
 * @generated from protobuf enum ics23.LengthOp
 */
export declare enum LengthOp {
    /**
     * NO_PREFIX don't include any length info
     *
     * @generated from protobuf enum value: NO_PREFIX = 0;
     */
    NO_PREFIX = 0,
    /**
     * VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
     *
     * @generated from protobuf enum value: VAR_PROTO = 1;
     */
    VAR_PROTO = 1,
    /**
     * VAR_RLP uses rlp int encoding of the length
     *
     * @generated from protobuf enum value: VAR_RLP = 2;
     */
    VAR_RLP = 2,
    /**
     * FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
     *
     * @generated from protobuf enum value: FIXED32_BIG = 3;
     */
    FIXED32_BIG = 3,
    /**
     * FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
     *
     * @generated from protobuf enum value: FIXED32_LITTLE = 4;
     */
    FIXED32_LITTLE = 4,
    /**
     * FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
     *
     * @generated from protobuf enum value: FIXED64_BIG = 5;
     */
    FIXED64_BIG = 5,
    /**
     * FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
     *
     * @generated from protobuf enum value: FIXED64_LITTLE = 6;
     */
    FIXED64_LITTLE = 6,
    /**
     * REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
     *
     * @generated from protobuf enum value: REQUIRE_32_BYTES = 7;
     */
    REQUIRE_32_BYTES = 7,
    /**
     * REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
     *
     * @generated from protobuf enum value: REQUIRE_64_BYTES = 8;
     */
    REQUIRE_64_BYTES = 8
}
declare class ExistenceProof$Type extends MessageType<ExistenceProof> {
    constructor();
    create(value?: PartialMessage<ExistenceProof>): ExistenceProof;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExistenceProof): ExistenceProof;
    internalBinaryWrite(message: ExistenceProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.ExistenceProof
 */
export declare const ExistenceProof: ExistenceProof$Type;
declare class NonExistenceProof$Type extends MessageType<NonExistenceProof> {
    constructor();
    create(value?: PartialMessage<NonExistenceProof>): NonExistenceProof;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NonExistenceProof): NonExistenceProof;
    internalBinaryWrite(message: NonExistenceProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.NonExistenceProof
 */
export declare const NonExistenceProof: NonExistenceProof$Type;
declare class CommitmentProof$Type extends MessageType<CommitmentProof> {
    constructor();
    create(value?: PartialMessage<CommitmentProof>): CommitmentProof;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommitmentProof): CommitmentProof;
    internalBinaryWrite(message: CommitmentProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.CommitmentProof
 */
export declare const CommitmentProof: CommitmentProof$Type;
declare class LeafOp$Type extends MessageType<LeafOp> {
    constructor();
    create(value?: PartialMessage<LeafOp>): LeafOp;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeafOp): LeafOp;
    internalBinaryWrite(message: LeafOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.LeafOp
 */
export declare const LeafOp: LeafOp$Type;
declare class InnerOp$Type extends MessageType<InnerOp> {
    constructor();
    create(value?: PartialMessage<InnerOp>): InnerOp;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InnerOp): InnerOp;
    internalBinaryWrite(message: InnerOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.InnerOp
 */
export declare const InnerOp: InnerOp$Type;
declare class ProofSpec$Type extends MessageType<ProofSpec> {
    constructor();
    create(value?: PartialMessage<ProofSpec>): ProofSpec;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProofSpec): ProofSpec;
    internalBinaryWrite(message: ProofSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.ProofSpec
 */
export declare const ProofSpec: ProofSpec$Type;
declare class InnerSpec$Type extends MessageType<InnerSpec> {
    constructor();
    create(value?: PartialMessage<InnerSpec>): InnerSpec;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InnerSpec): InnerSpec;
    internalBinaryWrite(message: InnerSpec, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.InnerSpec
 */
export declare const InnerSpec: InnerSpec$Type;
declare class BatchProof$Type extends MessageType<BatchProof> {
    constructor();
    create(value?: PartialMessage<BatchProof>): BatchProof;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchProof): BatchProof;
    internalBinaryWrite(message: BatchProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.BatchProof
 */
export declare const BatchProof: BatchProof$Type;
declare class BatchEntry$Type extends MessageType<BatchEntry> {
    constructor();
    create(value?: PartialMessage<BatchEntry>): BatchEntry;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchEntry): BatchEntry;
    internalBinaryWrite(message: BatchEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.BatchEntry
 */
export declare const BatchEntry: BatchEntry$Type;
declare class CompressedBatchProof$Type extends MessageType<CompressedBatchProof> {
    constructor();
    create(value?: PartialMessage<CompressedBatchProof>): CompressedBatchProof;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompressedBatchProof): CompressedBatchProof;
    internalBinaryWrite(message: CompressedBatchProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.CompressedBatchProof
 */
export declare const CompressedBatchProof: CompressedBatchProof$Type;
declare class CompressedBatchEntry$Type extends MessageType<CompressedBatchEntry> {
    constructor();
    create(value?: PartialMessage<CompressedBatchEntry>): CompressedBatchEntry;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompressedBatchEntry): CompressedBatchEntry;
    internalBinaryWrite(message: CompressedBatchEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.CompressedBatchEntry
 */
export declare const CompressedBatchEntry: CompressedBatchEntry$Type;
declare class CompressedExistenceProof$Type extends MessageType<CompressedExistenceProof> {
    constructor();
    create(value?: PartialMessage<CompressedExistenceProof>): CompressedExistenceProof;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompressedExistenceProof): CompressedExistenceProof;
    internalBinaryWrite(message: CompressedExistenceProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.CompressedExistenceProof
 */
export declare const CompressedExistenceProof: CompressedExistenceProof$Type;
declare class CompressedNonExistenceProof$Type extends MessageType<CompressedNonExistenceProof> {
    constructor();
    create(value?: PartialMessage<CompressedNonExistenceProof>): CompressedNonExistenceProof;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompressedNonExistenceProof): CompressedNonExistenceProof;
    internalBinaryWrite(message: CompressedNonExistenceProof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ics23.CompressedNonExistenceProof
 */
export declare const CompressedNonExistenceProof: CompressedNonExistenceProof$Type;
export {};
