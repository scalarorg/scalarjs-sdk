// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "tendermint/abci/types.proto" (package "tendermint.abci", syntax proto3)
// tslint:disable
// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "tendermint/abci/types.proto" (package "tendermint.abci", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PublicKey } from "../crypto/keys";
import { VersionParams } from "../types/params";
import { ValidatorParams } from "../types/params";
import { EvidenceParams } from "../types/params";
import { ProofOps } from "../crypto/proof";
import { Header } from "../types/types";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * @generated from protobuf enum tendermint.abci.ResponseOfferSnapshot.Result
 */
export var ResponseOfferSnapshot_Result;
(function (ResponseOfferSnapshot_Result) {
    /**
     * Unknown result, abort all snapshot restoration
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Snapshot accepted, apply chunks
     *
     * @generated from protobuf enum value: ACCEPT = 1;
     */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["ACCEPT"] = 1] = "ACCEPT";
    /**
     * Abort all snapshot restoration
     *
     * @generated from protobuf enum value: ABORT = 2;
     */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["ABORT"] = 2] = "ABORT";
    /**
     * Reject this specific snapshot, try others
     *
     * @generated from protobuf enum value: REJECT = 3;
     */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT"] = 3] = "REJECT";
    /**
     * Reject all snapshots of this format, try others
     *
     * @generated from protobuf enum value: REJECT_FORMAT = 4;
     */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
    /**
     * Reject all snapshots from the sender(s), try others
     *
     * @generated from protobuf enum value: REJECT_SENDER = 5;
     */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT_SENDER"] = 5] = "REJECT_SENDER";
})(ResponseOfferSnapshot_Result || (ResponseOfferSnapshot_Result = {}));
/**
 * @generated from protobuf enum tendermint.abci.ResponseApplySnapshotChunk.Result
 */
export var ResponseApplySnapshotChunk_Result;
(function (ResponseApplySnapshotChunk_Result) {
    /**
     * Unknown result, abort all snapshot restoration
     *
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Chunk successfully accepted
     *
     * @generated from protobuf enum value: ACCEPT = 1;
     */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["ACCEPT"] = 1] = "ACCEPT";
    /**
     * Abort all snapshot restoration
     *
     * @generated from protobuf enum value: ABORT = 2;
     */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["ABORT"] = 2] = "ABORT";
    /**
     * Retry chunk (combine with refetch and reject)
     *
     * @generated from protobuf enum value: RETRY = 3;
     */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["RETRY"] = 3] = "RETRY";
    /**
     * Retry snapshot (combine with refetch and reject)
     *
     * @generated from protobuf enum value: RETRY_SNAPSHOT = 4;
     */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
    /**
     * Reject this snapshot, try others
     *
     * @generated from protobuf enum value: REJECT_SNAPSHOT = 5;
     */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
})(ResponseApplySnapshotChunk_Result || (ResponseApplySnapshotChunk_Result = {}));
/**
 * @generated from protobuf enum tendermint.abci.CheckTxType
 */
export var CheckTxType;
(function (CheckTxType) {
    /**
     * @generated from protobuf enum value: NEW = 0;
     */
    CheckTxType[CheckTxType["NEW"] = 0] = "NEW";
    /**
     * @generated from protobuf enum value: RECHECK = 1;
     */
    CheckTxType[CheckTxType["RECHECK"] = 1] = "RECHECK";
})(CheckTxType || (CheckTxType = {}));
/**
 * @generated from protobuf enum tendermint.abci.EvidenceType
 */
export var EvidenceType;
(function (EvidenceType) {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    EvidenceType[EvidenceType["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * @generated from protobuf enum value: DUPLICATE_VOTE = 1;
     */
    EvidenceType[EvidenceType["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
    /**
     * @generated from protobuf enum value: LIGHT_CLIENT_ATTACK = 2;
     */
    EvidenceType[EvidenceType["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
})(EvidenceType || (EvidenceType = {}));
// @generated message type with reflection information, may provide speed optimized methods
class Request$Type extends MessageType {
    constructor() {
        super("tendermint.abci.Request", [
            { no: 1, name: "echo", kind: "message", oneof: "value", T: () => RequestEcho },
            { no: 2, name: "flush", kind: "message", oneof: "value", T: () => RequestFlush },
            { no: 3, name: "info", kind: "message", oneof: "value", T: () => RequestInfo },
            { no: 4, name: "set_option", kind: "message", oneof: "value", T: () => RequestSetOption },
            { no: 5, name: "init_chain", kind: "message", oneof: "value", T: () => RequestInitChain },
            { no: 6, name: "query", kind: "message", oneof: "value", T: () => RequestQuery },
            { no: 7, name: "begin_block", kind: "message", oneof: "value", T: () => RequestBeginBlock },
            { no: 8, name: "check_tx", kind: "message", oneof: "value", T: () => RequestCheckTx },
            { no: 9, name: "deliver_tx", kind: "message", oneof: "value", T: () => RequestDeliverTx },
            { no: 10, name: "end_block", kind: "message", oneof: "value", T: () => RequestEndBlock },
            { no: 11, name: "commit", kind: "message", oneof: "value", T: () => RequestCommit },
            { no: 12, name: "list_snapshots", kind: "message", oneof: "value", T: () => RequestListSnapshots },
            { no: 13, name: "offer_snapshot", kind: "message", oneof: "value", T: () => RequestOfferSnapshot },
            { no: 14, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => RequestLoadSnapshotChunk },
            { no: 15, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => RequestApplySnapshotChunk }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.RequestEcho echo */ 1:
                    message.value = {
                        oneofKind: "echo",
                        echo: RequestEcho.internalBinaryRead(reader, reader.uint32(), options, message.value.echo)
                    };
                    break;
                case /* tendermint.abci.RequestFlush flush */ 2:
                    message.value = {
                        oneofKind: "flush",
                        flush: RequestFlush.internalBinaryRead(reader, reader.uint32(), options, message.value.flush)
                    };
                    break;
                case /* tendermint.abci.RequestInfo info */ 3:
                    message.value = {
                        oneofKind: "info",
                        info: RequestInfo.internalBinaryRead(reader, reader.uint32(), options, message.value.info)
                    };
                    break;
                case /* tendermint.abci.RequestSetOption set_option */ 4:
                    message.value = {
                        oneofKind: "setOption",
                        setOption: RequestSetOption.internalBinaryRead(reader, reader.uint32(), options, message.value.setOption)
                    };
                    break;
                case /* tendermint.abci.RequestInitChain init_chain */ 5:
                    message.value = {
                        oneofKind: "initChain",
                        initChain: RequestInitChain.internalBinaryRead(reader, reader.uint32(), options, message.value.initChain)
                    };
                    break;
                case /* tendermint.abci.RequestQuery query */ 6:
                    message.value = {
                        oneofKind: "query",
                        query: RequestQuery.internalBinaryRead(reader, reader.uint32(), options, message.value.query)
                    };
                    break;
                case /* tendermint.abci.RequestBeginBlock begin_block */ 7:
                    message.value = {
                        oneofKind: "beginBlock",
                        beginBlock: RequestBeginBlock.internalBinaryRead(reader, reader.uint32(), options, message.value.beginBlock)
                    };
                    break;
                case /* tendermint.abci.RequestCheckTx check_tx */ 8:
                    message.value = {
                        oneofKind: "checkTx",
                        checkTx: RequestCheckTx.internalBinaryRead(reader, reader.uint32(), options, message.value.checkTx)
                    };
                    break;
                case /* tendermint.abci.RequestDeliverTx deliver_tx */ 9:
                    message.value = {
                        oneofKind: "deliverTx",
                        deliverTx: RequestDeliverTx.internalBinaryRead(reader, reader.uint32(), options, message.value.deliverTx)
                    };
                    break;
                case /* tendermint.abci.RequestEndBlock end_block */ 10:
                    message.value = {
                        oneofKind: "endBlock",
                        endBlock: RequestEndBlock.internalBinaryRead(reader, reader.uint32(), options, message.value.endBlock)
                    };
                    break;
                case /* tendermint.abci.RequestCommit commit */ 11:
                    message.value = {
                        oneofKind: "commit",
                        commit: RequestCommit.internalBinaryRead(reader, reader.uint32(), options, message.value.commit)
                    };
                    break;
                case /* tendermint.abci.RequestListSnapshots list_snapshots */ 12:
                    message.value = {
                        oneofKind: "listSnapshots",
                        listSnapshots: RequestListSnapshots.internalBinaryRead(reader, reader.uint32(), options, message.value.listSnapshots)
                    };
                    break;
                case /* tendermint.abci.RequestOfferSnapshot offer_snapshot */ 13:
                    message.value = {
                        oneofKind: "offerSnapshot",
                        offerSnapshot: RequestOfferSnapshot.internalBinaryRead(reader, reader.uint32(), options, message.value.offerSnapshot)
                    };
                    break;
                case /* tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk */ 14:
                    message.value = {
                        oneofKind: "loadSnapshotChunk",
                        loadSnapshotChunk: RequestLoadSnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, message.value.loadSnapshotChunk)
                    };
                    break;
                case /* tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk */ 15:
                    message.value = {
                        oneofKind: "applySnapshotChunk",
                        applySnapshotChunk: RequestApplySnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, message.value.applySnapshotChunk)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.abci.RequestEcho echo = 1; */
        if (message.value.oneofKind === "echo")
            RequestEcho.internalBinaryWrite(message.value.echo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestFlush flush = 2; */
        if (message.value.oneofKind === "flush")
            RequestFlush.internalBinaryWrite(message.value.flush, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestInfo info = 3; */
        if (message.value.oneofKind === "info")
            RequestInfo.internalBinaryWrite(message.value.info, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestSetOption set_option = 4; */
        if (message.value.oneofKind === "setOption")
            RequestSetOption.internalBinaryWrite(message.value.setOption, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestInitChain init_chain = 5; */
        if (message.value.oneofKind === "initChain")
            RequestInitChain.internalBinaryWrite(message.value.initChain, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestQuery query = 6; */
        if (message.value.oneofKind === "query")
            RequestQuery.internalBinaryWrite(message.value.query, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestBeginBlock begin_block = 7; */
        if (message.value.oneofKind === "beginBlock")
            RequestBeginBlock.internalBinaryWrite(message.value.beginBlock, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestCheckTx check_tx = 8; */
        if (message.value.oneofKind === "checkTx")
            RequestCheckTx.internalBinaryWrite(message.value.checkTx, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestDeliverTx deliver_tx = 9; */
        if (message.value.oneofKind === "deliverTx")
            RequestDeliverTx.internalBinaryWrite(message.value.deliverTx, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestEndBlock end_block = 10; */
        if (message.value.oneofKind === "endBlock")
            RequestEndBlock.internalBinaryWrite(message.value.endBlock, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestCommit commit = 11; */
        if (message.value.oneofKind === "commit")
            RequestCommit.internalBinaryWrite(message.value.commit, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestListSnapshots list_snapshots = 12; */
        if (message.value.oneofKind === "listSnapshots")
            RequestListSnapshots.internalBinaryWrite(message.value.listSnapshots, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestOfferSnapshot offer_snapshot = 13; */
        if (message.value.oneofKind === "offerSnapshot")
            RequestOfferSnapshot.internalBinaryWrite(message.value.offerSnapshot, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14; */
        if (message.value.oneofKind === "loadSnapshotChunk")
            RequestLoadSnapshotChunk.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15; */
        if (message.value.oneofKind === "applySnapshotChunk")
            RequestApplySnapshotChunk.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Request
 */
export const Request = new Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestEcho$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestEcho", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestEcho
 */
export const RequestEcho = new RequestEcho$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestFlush$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestFlush", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestFlush
 */
export const RequestFlush = new RequestFlush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestInfo$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestInfo", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "block_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 3, name: "p2p_version", kind: "scalar", jsonName: "p2pVersion", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.version = "";
        message.blockVersion = "0";
        message.p2PVersion = "0";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* uint64 block_version */ 2:
                    message.blockVersion = reader.uint64().toString();
                    break;
                case /* uint64 p2p_version = 3 [json_name = "p2pVersion"];*/ 3:
                    message.p2PVersion = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* uint64 block_version = 2; */
        if (message.blockVersion !== "0")
            writer.tag(2, WireType.Varint).uint64(message.blockVersion);
        /* uint64 p2p_version = 3 [json_name = "p2pVersion"]; */
        if (message.p2PVersion !== "0")
            writer.tag(3, WireType.Varint).uint64(message.p2PVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestInfo
 */
export const RequestInfo = new RequestInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestSetOption$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestSetOption", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.key = "";
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestSetOption
 */
export const RequestSetOption = new RequestSetOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestInitChain$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestInitChain", [
            { no: 1, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 2, name: "chain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "consensus_params", kind: "message", T: () => ConsensusParams },
            { no: 4, name: "validators", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 5, name: "app_state_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "initial_height", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.chainId = "";
        message.validators = [];
        message.appStateBytes = new Uint8Array(0);
        message.initialHeight = "0";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp time */ 1:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* string chain_id */ 2:
                    message.chainId = reader.string();
                    break;
                case /* tendermint.abci.ConsensusParams consensus_params */ 3:
                    message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
                    break;
                case /* repeated tendermint.abci.ValidatorUpdate validators */ 4:
                    message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes app_state_bytes */ 5:
                    message.appStateBytes = reader.bytes();
                    break;
                case /* int64 initial_height */ 6:
                    message.initialHeight = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* google.protobuf.Timestamp time = 1; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string chain_id = 2; */
        if (message.chainId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.chainId);
        /* tendermint.abci.ConsensusParams consensus_params = 3; */
        if (message.consensusParams)
            ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.ValidatorUpdate validators = 4; */
        for (let i = 0; i < message.validators.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_state_bytes = 5; */
        if (message.appStateBytes.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.appStateBytes);
        /* int64 initial_height = 6; */
        if (message.initialHeight !== "0")
            writer.tag(6, WireType.Varint).int64(message.initialHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestInitChain
 */
export const RequestInitChain = new RequestInitChain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestQuery$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestQuery", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "prove", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.data = new Uint8Array(0);
        message.path = "";
        message.height = "0";
        message.prove = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toString();
                    break;
                case /* bool prove */ 4:
                    message.prove = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* int64 height = 3; */
        if (message.height !== "0")
            writer.tag(3, WireType.Varint).int64(message.height);
        /* bool prove = 4; */
        if (message.prove !== false)
            writer.tag(4, WireType.Varint).bool(message.prove);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestQuery
 */
export const RequestQuery = new RequestQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestBeginBlock$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestBeginBlock", [
            { no: 1, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "header", kind: "message", T: () => Header, options: { "gogoproto.nullable": false } },
            { no: 3, name: "last_commit_info", kind: "message", T: () => LastCommitInfo, options: { "gogoproto.nullable": false } },
            { no: 4, name: "byzantine_validators", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Evidence, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.hash = new Uint8Array(0);
        message.byzantineValidators = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hash */ 1:
                    message.hash = reader.bytes();
                    break;
                case /* tendermint.types.Header header */ 2:
                    message.header = Header.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* tendermint.abci.LastCommitInfo last_commit_info */ 3:
                    message.lastCommitInfo = LastCommitInfo.internalBinaryRead(reader, reader.uint32(), options, message.lastCommitInfo);
                    break;
                case /* repeated tendermint.abci.Evidence byzantine_validators */ 4:
                    message.byzantineValidators.push(Evidence.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes hash = 1; */
        if (message.hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hash);
        /* tendermint.types.Header header = 2; */
        if (message.header)
            Header.internalBinaryWrite(message.header, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.LastCommitInfo last_commit_info = 3; */
        if (message.lastCommitInfo)
            LastCommitInfo.internalBinaryWrite(message.lastCommitInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.Evidence byzantine_validators = 4; */
        for (let i = 0; i < message.byzantineValidators.length; i++)
            Evidence.internalBinaryWrite(message.byzantineValidators[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestBeginBlock
 */
export const RequestBeginBlock = new RequestBeginBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestCheckTx$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestCheckTx", [
            { no: 1, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["tendermint.abci.CheckTxType", CheckTxType] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.tx = new Uint8Array(0);
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tx */ 1:
                    message.tx = reader.bytes();
                    break;
                case /* tendermint.abci.CheckTxType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes tx = 1; */
        if (message.tx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
        /* tendermint.abci.CheckTxType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestCheckTx
 */
export const RequestCheckTx = new RequestCheckTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestDeliverTx$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestDeliverTx", [
            { no: 1, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.tx = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes tx */ 1:
                    message.tx = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes tx = 1; */
        if (message.tx.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.tx);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestDeliverTx
 */
export const RequestDeliverTx = new RequestDeliverTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestEndBlock$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestEndBlock", [
            { no: 1, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.height = "0";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 height */ 1:
                    message.height = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 height = 1; */
        if (message.height !== "0")
            writer.tag(1, WireType.Varint).int64(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestEndBlock
 */
export const RequestEndBlock = new RequestEndBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestCommit$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestCommit", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestCommit
 */
export const RequestCommit = new RequestCommit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestListSnapshots$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestListSnapshots", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestListSnapshots
 */
export const RequestListSnapshots = new RequestListSnapshots$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestOfferSnapshot$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestOfferSnapshot", [
            { no: 1, name: "snapshot", kind: "message", T: () => Snapshot },
            { no: 2, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.appHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.Snapshot snapshot */ 1:
                    message.snapshot = Snapshot.internalBinaryRead(reader, reader.uint32(), options, message.snapshot);
                    break;
                case /* bytes app_hash */ 2:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.abci.Snapshot snapshot = 1; */
        if (message.snapshot)
            Snapshot.internalBinaryWrite(message.snapshot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 2; */
        if (message.appHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestOfferSnapshot
 */
export const RequestOfferSnapshot = new RequestOfferSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestLoadSnapshotChunk$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestLoadSnapshotChunk", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "format", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "chunk", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.height = "0";
        message.format = 0;
        message.chunk = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toString();
                    break;
                case /* uint32 format */ 2:
                    message.format = reader.uint32();
                    break;
                case /* uint32 chunk */ 3:
                    message.chunk = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 height = 1; */
        if (message.height !== "0")
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* uint32 format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).uint32(message.format);
        /* uint32 chunk = 3; */
        if (message.chunk !== 0)
            writer.tag(3, WireType.Varint).uint32(message.chunk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestLoadSnapshotChunk
 */
export const RequestLoadSnapshotChunk = new RequestLoadSnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestApplySnapshotChunk$Type extends MessageType {
    constructor() {
        super("tendermint.abci.RequestApplySnapshotChunk", [
            { no: 1, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "chunk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.index = 0;
        message.chunk = new Uint8Array(0);
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 index */ 1:
                    message.index = reader.uint32();
                    break;
                case /* bytes chunk */ 2:
                    message.chunk = reader.bytes();
                    break;
                case /* string sender */ 3:
                    message.sender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 index = 1; */
        if (message.index !== 0)
            writer.tag(1, WireType.Varint).uint32(message.index);
        /* bytes chunk = 2; */
        if (message.chunk.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.chunk);
        /* string sender = 3; */
        if (message.sender !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.RequestApplySnapshotChunk
 */
export const RequestApplySnapshotChunk = new RequestApplySnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Response$Type extends MessageType {
    constructor() {
        super("tendermint.abci.Response", [
            { no: 1, name: "exception", kind: "message", oneof: "value", T: () => ResponseException },
            { no: 2, name: "echo", kind: "message", oneof: "value", T: () => ResponseEcho },
            { no: 3, name: "flush", kind: "message", oneof: "value", T: () => ResponseFlush },
            { no: 4, name: "info", kind: "message", oneof: "value", T: () => ResponseInfo },
            { no: 5, name: "set_option", kind: "message", oneof: "value", T: () => ResponseSetOption },
            { no: 6, name: "init_chain", kind: "message", oneof: "value", T: () => ResponseInitChain },
            { no: 7, name: "query", kind: "message", oneof: "value", T: () => ResponseQuery },
            { no: 8, name: "begin_block", kind: "message", oneof: "value", T: () => ResponseBeginBlock },
            { no: 9, name: "check_tx", kind: "message", oneof: "value", T: () => ResponseCheckTx },
            { no: 10, name: "deliver_tx", kind: "message", oneof: "value", T: () => ResponseDeliverTx },
            { no: 11, name: "end_block", kind: "message", oneof: "value", T: () => ResponseEndBlock },
            { no: 12, name: "commit", kind: "message", oneof: "value", T: () => ResponseCommit },
            { no: 13, name: "list_snapshots", kind: "message", oneof: "value", T: () => ResponseListSnapshots },
            { no: 14, name: "offer_snapshot", kind: "message", oneof: "value", T: () => ResponseOfferSnapshot },
            { no: 15, name: "load_snapshot_chunk", kind: "message", oneof: "value", T: () => ResponseLoadSnapshotChunk },
            { no: 16, name: "apply_snapshot_chunk", kind: "message", oneof: "value", T: () => ResponseApplySnapshotChunk }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseException exception */ 1:
                    message.value = {
                        oneofKind: "exception",
                        exception: ResponseException.internalBinaryRead(reader, reader.uint32(), options, message.value.exception)
                    };
                    break;
                case /* tendermint.abci.ResponseEcho echo */ 2:
                    message.value = {
                        oneofKind: "echo",
                        echo: ResponseEcho.internalBinaryRead(reader, reader.uint32(), options, message.value.echo)
                    };
                    break;
                case /* tendermint.abci.ResponseFlush flush */ 3:
                    message.value = {
                        oneofKind: "flush",
                        flush: ResponseFlush.internalBinaryRead(reader, reader.uint32(), options, message.value.flush)
                    };
                    break;
                case /* tendermint.abci.ResponseInfo info */ 4:
                    message.value = {
                        oneofKind: "info",
                        info: ResponseInfo.internalBinaryRead(reader, reader.uint32(), options, message.value.info)
                    };
                    break;
                case /* tendermint.abci.ResponseSetOption set_option */ 5:
                    message.value = {
                        oneofKind: "setOption",
                        setOption: ResponseSetOption.internalBinaryRead(reader, reader.uint32(), options, message.value.setOption)
                    };
                    break;
                case /* tendermint.abci.ResponseInitChain init_chain */ 6:
                    message.value = {
                        oneofKind: "initChain",
                        initChain: ResponseInitChain.internalBinaryRead(reader, reader.uint32(), options, message.value.initChain)
                    };
                    break;
                case /* tendermint.abci.ResponseQuery query */ 7:
                    message.value = {
                        oneofKind: "query",
                        query: ResponseQuery.internalBinaryRead(reader, reader.uint32(), options, message.value.query)
                    };
                    break;
                case /* tendermint.abci.ResponseBeginBlock begin_block */ 8:
                    message.value = {
                        oneofKind: "beginBlock",
                        beginBlock: ResponseBeginBlock.internalBinaryRead(reader, reader.uint32(), options, message.value.beginBlock)
                    };
                    break;
                case /* tendermint.abci.ResponseCheckTx check_tx */ 9:
                    message.value = {
                        oneofKind: "checkTx",
                        checkTx: ResponseCheckTx.internalBinaryRead(reader, reader.uint32(), options, message.value.checkTx)
                    };
                    break;
                case /* tendermint.abci.ResponseDeliverTx deliver_tx */ 10:
                    message.value = {
                        oneofKind: "deliverTx",
                        deliverTx: ResponseDeliverTx.internalBinaryRead(reader, reader.uint32(), options, message.value.deliverTx)
                    };
                    break;
                case /* tendermint.abci.ResponseEndBlock end_block */ 11:
                    message.value = {
                        oneofKind: "endBlock",
                        endBlock: ResponseEndBlock.internalBinaryRead(reader, reader.uint32(), options, message.value.endBlock)
                    };
                    break;
                case /* tendermint.abci.ResponseCommit commit */ 12:
                    message.value = {
                        oneofKind: "commit",
                        commit: ResponseCommit.internalBinaryRead(reader, reader.uint32(), options, message.value.commit)
                    };
                    break;
                case /* tendermint.abci.ResponseListSnapshots list_snapshots */ 13:
                    message.value = {
                        oneofKind: "listSnapshots",
                        listSnapshots: ResponseListSnapshots.internalBinaryRead(reader, reader.uint32(), options, message.value.listSnapshots)
                    };
                    break;
                case /* tendermint.abci.ResponseOfferSnapshot offer_snapshot */ 14:
                    message.value = {
                        oneofKind: "offerSnapshot",
                        offerSnapshot: ResponseOfferSnapshot.internalBinaryRead(reader, reader.uint32(), options, message.value.offerSnapshot)
                    };
                    break;
                case /* tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk */ 15:
                    message.value = {
                        oneofKind: "loadSnapshotChunk",
                        loadSnapshotChunk: ResponseLoadSnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, message.value.loadSnapshotChunk)
                    };
                    break;
                case /* tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk */ 16:
                    message.value = {
                        oneofKind: "applySnapshotChunk",
                        applySnapshotChunk: ResponseApplySnapshotChunk.internalBinaryRead(reader, reader.uint32(), options, message.value.applySnapshotChunk)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.abci.ResponseException exception = 1; */
        if (message.value.oneofKind === "exception")
            ResponseException.internalBinaryWrite(message.value.exception, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseEcho echo = 2; */
        if (message.value.oneofKind === "echo")
            ResponseEcho.internalBinaryWrite(message.value.echo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseFlush flush = 3; */
        if (message.value.oneofKind === "flush")
            ResponseFlush.internalBinaryWrite(message.value.flush, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseInfo info = 4; */
        if (message.value.oneofKind === "info")
            ResponseInfo.internalBinaryWrite(message.value.info, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseSetOption set_option = 5; */
        if (message.value.oneofKind === "setOption")
            ResponseSetOption.internalBinaryWrite(message.value.setOption, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseInitChain init_chain = 6; */
        if (message.value.oneofKind === "initChain")
            ResponseInitChain.internalBinaryWrite(message.value.initChain, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseQuery query = 7; */
        if (message.value.oneofKind === "query")
            ResponseQuery.internalBinaryWrite(message.value.query, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseBeginBlock begin_block = 8; */
        if (message.value.oneofKind === "beginBlock")
            ResponseBeginBlock.internalBinaryWrite(message.value.beginBlock, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseCheckTx check_tx = 9; */
        if (message.value.oneofKind === "checkTx")
            ResponseCheckTx.internalBinaryWrite(message.value.checkTx, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseDeliverTx deliver_tx = 10; */
        if (message.value.oneofKind === "deliverTx")
            ResponseDeliverTx.internalBinaryWrite(message.value.deliverTx, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseEndBlock end_block = 11; */
        if (message.value.oneofKind === "endBlock")
            ResponseEndBlock.internalBinaryWrite(message.value.endBlock, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseCommit commit = 12; */
        if (message.value.oneofKind === "commit")
            ResponseCommit.internalBinaryWrite(message.value.commit, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseListSnapshots list_snapshots = 13; */
        if (message.value.oneofKind === "listSnapshots")
            ResponseListSnapshots.internalBinaryWrite(message.value.listSnapshots, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14; */
        if (message.value.oneofKind === "offerSnapshot")
            ResponseOfferSnapshot.internalBinaryWrite(message.value.offerSnapshot, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15; */
        if (message.value.oneofKind === "loadSnapshotChunk")
            ResponseLoadSnapshotChunk.internalBinaryWrite(message.value.loadSnapshotChunk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16; */
        if (message.value.oneofKind === "applySnapshotChunk")
            ResponseApplySnapshotChunk.internalBinaryWrite(message.value.applySnapshotChunk, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Response
 */
export const Response = new Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseException$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseException", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseException
 */
export const ResponseException = new ResponseException$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseEcho$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseEcho", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseEcho
 */
export const ResponseEcho = new ResponseEcho$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseFlush$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseFlush", []);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target !== null && target !== void 0 ? target : this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseFlush
 */
export const ResponseFlush = new ResponseFlush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseInfo$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseInfo", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "app_version", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 4, name: "last_block_height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "last_block_app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.data = "";
        message.version = "";
        message.appVersion = "0";
        message.lastBlockHeight = "0";
        message.lastBlockAppHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                case /* string version */ 2:
                    message.version = reader.string();
                    break;
                case /* uint64 app_version */ 3:
                    message.appVersion = reader.uint64().toString();
                    break;
                case /* int64 last_block_height */ 4:
                    message.lastBlockHeight = reader.int64().toString();
                    break;
                case /* bytes last_block_app_hash */ 5:
                    message.lastBlockAppHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        /* string version = 2; */
        if (message.version !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.version);
        /* uint64 app_version = 3; */
        if (message.appVersion !== "0")
            writer.tag(3, WireType.Varint).uint64(message.appVersion);
        /* int64 last_block_height = 4; */
        if (message.lastBlockHeight !== "0")
            writer.tag(4, WireType.Varint).int64(message.lastBlockHeight);
        /* bytes last_block_app_hash = 5; */
        if (message.lastBlockAppHash.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.lastBlockAppHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseInfo
 */
export const ResponseInfo = new ResponseInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseSetOption$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseSetOption", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.code = 0;
        message.log = "";
        message.info = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseSetOption
 */
export const ResponseSetOption = new ResponseSetOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseInitChain$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseInitChain", [
            { no: 1, name: "consensus_params", kind: "message", T: () => ConsensusParams },
            { no: 2, name: "validators", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 3, name: "app_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.validators = [];
        message.appHash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ConsensusParams consensus_params */ 1:
                    message.consensusParams = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParams);
                    break;
                case /* repeated tendermint.abci.ValidatorUpdate validators */ 2:
                    message.validators.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes app_hash */ 3:
                    message.appHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.abci.ConsensusParams consensus_params = 1; */
        if (message.consensusParams)
            ConsensusParams.internalBinaryWrite(message.consensusParams, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.ValidatorUpdate validators = 2; */
        for (let i = 0; i < message.validators.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validators[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes app_hash = 3; */
        if (message.appHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.appHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseInitChain
 */
export const ResponseInitChain = new ResponseInitChain$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseQuery$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseQuery", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "index", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "proof_ops", kind: "message", T: () => ProofOps },
            { no: 9, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 10, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.code = 0;
        message.log = "";
        message.info = "";
        message.index = "0";
        message.key = new Uint8Array(0);
        message.value = new Uint8Array(0);
        message.height = "0";
        message.codespace = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 index */ 5:
                    message.index = reader.int64().toString();
                    break;
                case /* bytes key */ 6:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 7:
                    message.value = reader.bytes();
                    break;
                case /* tendermint.crypto.ProofOps proof_ops */ 8:
                    message.proofOps = ProofOps.internalBinaryRead(reader, reader.uint32(), options, message.proofOps);
                    break;
                case /* int64 height */ 9:
                    message.height = reader.int64().toString();
                    break;
                case /* string codespace */ 10:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 index = 5; */
        if (message.index !== "0")
            writer.tag(5, WireType.Varint).int64(message.index);
        /* bytes key = 6; */
        if (message.key.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 7; */
        if (message.value.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.value);
        /* tendermint.crypto.ProofOps proof_ops = 8; */
        if (message.proofOps)
            ProofOps.internalBinaryWrite(message.proofOps, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 9; */
        if (message.height !== "0")
            writer.tag(9, WireType.Varint).int64(message.height);
        /* string codespace = 10; */
        if (message.codespace !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseQuery
 */
export const ResponseQuery = new ResponseQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseBeginBlock$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseBeginBlock", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tendermint.abci.Event events */ 1:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated tendermint.abci.Event events = 1; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseBeginBlock
 */
export const ResponseBeginBlock = new ResponseBeginBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseCheckTx$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseCheckTx", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gas_wanted", kind: "scalar", jsonName: "gas_wanted", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "gas_used", kind: "scalar", jsonName: "gas_used", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 8, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "priority", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 11, name: "mempool_error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.code = 0;
        message.data = new Uint8Array(0);
        message.log = "";
        message.info = "";
        message.gasWanted = "0";
        message.gasUsed = "0";
        message.events = [];
        message.codespace = "";
        message.sender = "";
        message.priority = "0";
        message.mempoolError = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 gas_wanted = 5 [json_name = "gas_wanted"];*/ 5:
                    message.gasWanted = reader.int64().toString();
                    break;
                case /* int64 gas_used = 6 [json_name = "gas_used"];*/ 6:
                    message.gasUsed = reader.int64().toString();
                    break;
                case /* repeated tendermint.abci.Event events */ 7:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string codespace */ 8:
                    message.codespace = reader.string();
                    break;
                case /* string sender */ 9:
                    message.sender = reader.string();
                    break;
                case /* int64 priority */ 10:
                    message.priority = reader.int64().toString();
                    break;
                case /* string mempool_error */ 11:
                    message.mempoolError = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 gas_wanted = 5 [json_name = "gas_wanted"]; */
        if (message.gasWanted !== "0")
            writer.tag(5, WireType.Varint).int64(message.gasWanted);
        /* int64 gas_used = 6 [json_name = "gas_used"]; */
        if (message.gasUsed !== "0")
            writer.tag(6, WireType.Varint).int64(message.gasUsed);
        /* repeated tendermint.abci.Event events = 7; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string codespace = 8; */
        if (message.codespace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codespace);
        /* string sender = 9; */
        if (message.sender !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.sender);
        /* int64 priority = 10; */
        if (message.priority !== "0")
            writer.tag(10, WireType.Varint).int64(message.priority);
        /* string mempool_error = 11; */
        if (message.mempoolError !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.mempoolError);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseCheckTx
 */
export const ResponseCheckTx = new ResponseCheckTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseDeliverTx$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseDeliverTx", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "log", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gas_wanted", kind: "scalar", jsonName: "gas_wanted", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "gas_used", kind: "scalar", jsonName: "gas_used", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } },
            { no: 8, name: "codespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.code = 0;
        message.data = new Uint8Array(0);
        message.log = "";
        message.info = "";
        message.gasWanted = "0";
        message.gasUsed = "0";
        message.events = [];
        message.codespace = "";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* string log */ 3:
                    message.log = reader.string();
                    break;
                case /* string info */ 4:
                    message.info = reader.string();
                    break;
                case /* int64 gas_wanted = 5 [json_name = "gas_wanted"];*/ 5:
                    message.gasWanted = reader.int64().toString();
                    break;
                case /* int64 gas_used = 6 [json_name = "gas_used"];*/ 6:
                    message.gasUsed = reader.int64().toString();
                    break;
                case /* repeated tendermint.abci.Event events */ 7:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string codespace */ 8:
                    message.codespace = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* string log = 3; */
        if (message.log !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.log);
        /* string info = 4; */
        if (message.info !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.info);
        /* int64 gas_wanted = 5 [json_name = "gas_wanted"]; */
        if (message.gasWanted !== "0")
            writer.tag(5, WireType.Varint).int64(message.gasWanted);
        /* int64 gas_used = 6 [json_name = "gas_used"]; */
        if (message.gasUsed !== "0")
            writer.tag(6, WireType.Varint).int64(message.gasUsed);
        /* repeated tendermint.abci.Event events = 7; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string codespace = 8; */
        if (message.codespace !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.codespace);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseDeliverTx
 */
export const ResponseDeliverTx = new ResponseDeliverTx$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseEndBlock$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseEndBlock", [
            { no: 1, name: "validator_updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidatorUpdate, options: { "gogoproto.nullable": false } },
            { no: 2, name: "consensus_param_updates", kind: "message", T: () => ConsensusParams },
            { no: 3, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Event, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "events,omitempty" } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.validatorUpdates = [];
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tendermint.abci.ValidatorUpdate validator_updates */ 1:
                    message.validatorUpdates.push(ValidatorUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* tendermint.abci.ConsensusParams consensus_param_updates */ 2:
                    message.consensusParamUpdates = ConsensusParams.internalBinaryRead(reader, reader.uint32(), options, message.consensusParamUpdates);
                    break;
                case /* repeated tendermint.abci.Event events */ 3:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated tendermint.abci.ValidatorUpdate validator_updates = 1; */
        for (let i = 0; i < message.validatorUpdates.length; i++)
            ValidatorUpdate.internalBinaryWrite(message.validatorUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.abci.ConsensusParams consensus_param_updates = 2; */
        if (message.consensusParamUpdates)
            ConsensusParams.internalBinaryWrite(message.consensusParamUpdates, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tendermint.abci.Event events = 3; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseEndBlock
 */
export const ResponseEndBlock = new ResponseEndBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseCommit$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseCommit", [
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "retain_height", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.data = new Uint8Array(0);
        message.retainHeight = "0";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* int64 retain_height */ 3:
                    message.retainHeight = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* int64 retain_height = 3; */
        if (message.retainHeight !== "0")
            writer.tag(3, WireType.Varint).int64(message.retainHeight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseCommit
 */
export const ResponseCommit = new ResponseCommit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseListSnapshots$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseListSnapshots", [
            { no: 1, name: "snapshots", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Snapshot }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.snapshots = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tendermint.abci.Snapshot snapshots */ 1:
                    message.snapshots.push(Snapshot.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated tendermint.abci.Snapshot snapshots = 1; */
        for (let i = 0; i < message.snapshots.length; i++)
            Snapshot.internalBinaryWrite(message.snapshots[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseListSnapshots
 */
export const ResponseListSnapshots = new ResponseListSnapshots$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseOfferSnapshot$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseOfferSnapshot", [
            { no: 1, name: "result", kind: "enum", T: () => ["tendermint.abci.ResponseOfferSnapshot.Result", ResponseOfferSnapshot_Result] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.result = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseOfferSnapshot.Result result */ 1:
                    message.result = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.abci.ResponseOfferSnapshot.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseOfferSnapshot
 */
export const ResponseOfferSnapshot = new ResponseOfferSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseLoadSnapshotChunk$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseLoadSnapshotChunk", [
            { no: 1, name: "chunk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.chunk = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes chunk */ 1:
                    message.chunk = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes chunk = 1; */
        if (message.chunk.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.chunk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseLoadSnapshotChunk
 */
export const ResponseLoadSnapshotChunk = new ResponseLoadSnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseApplySnapshotChunk$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ResponseApplySnapshotChunk", [
            { no: 1, name: "result", kind: "enum", T: () => ["tendermint.abci.ResponseApplySnapshotChunk.Result", ResponseApplySnapshotChunk_Result] },
            { no: 2, name: "refetch_chunks", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "reject_senders", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.result = 0;
        message.refetchChunks = [];
        message.rejectSenders = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.ResponseApplySnapshotChunk.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* repeated uint32 refetch_chunks */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.refetchChunks.push(reader.uint32());
                    else
                        message.refetchChunks.push(reader.uint32());
                    break;
                case /* repeated string reject_senders */ 3:
                    message.rejectSenders.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.abci.ResponseApplySnapshotChunk.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* repeated uint32 refetch_chunks = 2; */
        if (message.refetchChunks.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.refetchChunks.length; i++)
                writer.uint32(message.refetchChunks[i]);
            writer.join();
        }
        /* repeated string reject_senders = 3; */
        for (let i = 0; i < message.rejectSenders.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.rejectSenders[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ResponseApplySnapshotChunk
 */
export const ResponseApplySnapshotChunk = new ResponseApplySnapshotChunk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConsensusParams$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ConsensusParams", [
            { no: 1, name: "block", kind: "message", T: () => BlockParams },
            { no: 2, name: "evidence", kind: "message", T: () => EvidenceParams },
            { no: 3, name: "validator", kind: "message", T: () => ValidatorParams },
            { no: 4, name: "version", kind: "message", T: () => VersionParams }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.BlockParams block */ 1:
                    message.block = BlockParams.internalBinaryRead(reader, reader.uint32(), options, message.block);
                    break;
                case /* tendermint.types.EvidenceParams evidence */ 2:
                    message.evidence = EvidenceParams.internalBinaryRead(reader, reader.uint32(), options, message.evidence);
                    break;
                case /* tendermint.types.ValidatorParams validator */ 3:
                    message.validator = ValidatorParams.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* tendermint.types.VersionParams version */ 4:
                    message.version = VersionParams.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.abci.BlockParams block = 1; */
        if (message.block)
            BlockParams.internalBinaryWrite(message.block, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.types.EvidenceParams evidence = 2; */
        if (message.evidence)
            EvidenceParams.internalBinaryWrite(message.evidence, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.types.ValidatorParams validator = 3; */
        if (message.validator)
            ValidatorParams.internalBinaryWrite(message.validator, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tendermint.types.VersionParams version = 4; */
        if (message.version)
            VersionParams.internalBinaryWrite(message.version, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ConsensusParams
 */
export const ConsensusParams = new ConsensusParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockParams$Type extends MessageType {
    constructor() {
        super("tendermint.abci.BlockParams", [
            { no: 1, name: "max_bytes", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "max_gas", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.maxBytes = "0";
        message.maxGas = "0";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 max_bytes */ 1:
                    message.maxBytes = reader.int64().toString();
                    break;
                case /* int64 max_gas */ 2:
                    message.maxGas = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 max_bytes = 1; */
        if (message.maxBytes !== "0")
            writer.tag(1, WireType.Varint).int64(message.maxBytes);
        /* int64 max_gas = 2; */
        if (message.maxGas !== "0")
            writer.tag(2, WireType.Varint).int64(message.maxGas);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.BlockParams
 */
export const BlockParams = new BlockParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LastCommitInfo$Type extends MessageType {
    constructor() {
        super("tendermint.abci.LastCommitInfo", [
            { no: 1, name: "round", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "votes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VoteInfo, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.round = 0;
        message.votes = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 round */ 1:
                    message.round = reader.int32();
                    break;
                case /* repeated tendermint.abci.VoteInfo votes */ 2:
                    message.votes.push(VoteInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int32 round = 1; */
        if (message.round !== 0)
            writer.tag(1, WireType.Varint).int32(message.round);
        /* repeated tendermint.abci.VoteInfo votes = 2; */
        for (let i = 0; i < message.votes.length; i++)
            VoteInfo.internalBinaryWrite(message.votes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.LastCommitInfo
 */
export const LastCommitInfo = new LastCommitInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType {
    constructor() {
        super("tendermint.abci.Event", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventAttribute, options: { "gogoproto.nullable": false, "gogoproto.jsontag": "attributes,omitempty" } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = "";
        message.attributes = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated tendermint.abci.EventAttribute attributes */ 2:
                    message.attributes.push(EventAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated tendermint.abci.EventAttribute attributes = 2; */
        for (let i = 0; i < message.attributes.length; i++)
            EventAttribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventAttribute$Type extends MessageType {
    constructor() {
        super("tendermint.abci.EventAttribute", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "index", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.key = new Uint8Array(0);
        message.value = new Uint8Array(0);
        message.index = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                case /* bool index */ 3:
                    message.index = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        /* bool index = 3; */
        if (message.index !== false)
            writer.tag(3, WireType.Varint).bool(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.EventAttribute
 */
export const EventAttribute = new EventAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxResult$Type extends MessageType {
    constructor() {
        super("tendermint.abci.TxResult", [
            { no: 1, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "tx", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "result", kind: "message", T: () => ResponseDeliverTx, options: { "gogoproto.nullable": false } }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.height = "0";
        message.index = 0;
        message.tx = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 height */ 1:
                    message.height = reader.int64().toString();
                    break;
                case /* uint32 index */ 2:
                    message.index = reader.uint32();
                    break;
                case /* bytes tx */ 3:
                    message.tx = reader.bytes();
                    break;
                case /* tendermint.abci.ResponseDeliverTx result */ 4:
                    message.result = ResponseDeliverTx.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 height = 1; */
        if (message.height !== "0")
            writer.tag(1, WireType.Varint).int64(message.height);
        /* uint32 index = 2; */
        if (message.index !== 0)
            writer.tag(2, WireType.Varint).uint32(message.index);
        /* bytes tx = 3; */
        if (message.tx.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.tx);
        /* tendermint.abci.ResponseDeliverTx result = 4; */
        if (message.result)
            ResponseDeliverTx.internalBinaryWrite(message.result, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.TxResult
 */
export const TxResult = new TxResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Validator$Type extends MessageType {
    constructor() {
        super("tendermint.abci.Validator", [
            { no: 1, name: "address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.address = new Uint8Array(0);
        message.power = "0";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes address */ 1:
                    message.address = reader.bytes();
                    break;
                case /* int64 power */ 3:
                    message.power = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes address = 1; */
        if (message.address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.address);
        /* int64 power = 3; */
        if (message.power !== "0")
            writer.tag(3, WireType.Varint).int64(message.power);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Validator
 */
export const Validator = new Validator$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidatorUpdate$Type extends MessageType {
    constructor() {
        super("tendermint.abci.ValidatorUpdate", [
            { no: 1, name: "pub_key", kind: "message", T: () => PublicKey, options: { "gogoproto.nullable": false } },
            { no: 2, name: "power", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.power = "0";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.crypto.PublicKey pub_key */ 1:
                    message.pubKey = PublicKey.internalBinaryRead(reader, reader.uint32(), options, message.pubKey);
                    break;
                case /* int64 power */ 2:
                    message.power = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.crypto.PublicKey pub_key = 1; */
        if (message.pubKey)
            PublicKey.internalBinaryWrite(message.pubKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 power = 2; */
        if (message.power !== "0")
            writer.tag(2, WireType.Varint).int64(message.power);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.ValidatorUpdate
 */
export const ValidatorUpdate = new ValidatorUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoteInfo$Type extends MessageType {
    constructor() {
        super("tendermint.abci.VoteInfo", [
            { no: 1, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 2, name: "signed_last_block", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.signedLastBlock = false;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.Validator validator */ 1:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* bool signed_last_block */ 2:
                    message.signedLastBlock = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.abci.Validator validator = 1; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool signed_last_block = 2; */
        if (message.signedLastBlock !== false)
            writer.tag(2, WireType.Varint).bool(message.signedLastBlock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.VoteInfo
 */
export const VoteInfo = new VoteInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Evidence$Type extends MessageType {
    constructor() {
        super("tendermint.abci.Evidence", [
            { no: 1, name: "type", kind: "enum", T: () => ["tendermint.abci.EvidenceType", EvidenceType] },
            { no: 2, name: "validator", kind: "message", T: () => Validator, options: { "gogoproto.nullable": false } },
            { no: 3, name: "height", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "time", kind: "message", T: () => Timestamp, options: { "gogoproto.nullable": false, "gogoproto.stdtime": true } },
            { no: 5, name: "total_voting_power", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.type = 0;
        message.height = "0";
        message.totalVotingPower = "0";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tendermint.abci.EvidenceType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* tendermint.abci.Validator validator */ 2:
                    message.validator = Validator.internalBinaryRead(reader, reader.uint32(), options, message.validator);
                    break;
                case /* int64 height */ 3:
                    message.height = reader.int64().toString();
                    break;
                case /* google.protobuf.Timestamp time */ 4:
                    message.time = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.time);
                    break;
                case /* int64 total_voting_power */ 5:
                    message.totalVotingPower = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* tendermint.abci.EvidenceType type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* tendermint.abci.Validator validator = 2; */
        if (message.validator)
            Validator.internalBinaryWrite(message.validator, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 height = 3; */
        if (message.height !== "0")
            writer.tag(3, WireType.Varint).int64(message.height);
        /* google.protobuf.Timestamp time = 4; */
        if (message.time)
            Timestamp.internalBinaryWrite(message.time, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int64 total_voting_power = 5; */
        if (message.totalVotingPower !== "0")
            writer.tag(5, WireType.Varint).int64(message.totalVotingPower);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Evidence
 */
export const Evidence = new Evidence$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Snapshot$Type extends MessageType {
    constructor() {
        super("tendermint.abci.Snapshot", [
            { no: 1, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 2, name: "format", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "chunks", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.height = "0";
        message.format = 0;
        message.chunks = 0;
        message.hash = new Uint8Array(0);
        message.metadata = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 height */ 1:
                    message.height = reader.uint64().toString();
                    break;
                case /* uint32 format */ 2:
                    message.format = reader.uint32();
                    break;
                case /* uint32 chunks */ 3:
                    message.chunks = reader.uint32();
                    break;
                case /* bytes hash */ 4:
                    message.hash = reader.bytes();
                    break;
                case /* bytes metadata */ 5:
                    message.metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint64 height = 1; */
        if (message.height !== "0")
            writer.tag(1, WireType.Varint).uint64(message.height);
        /* uint32 format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).uint32(message.format);
        /* uint32 chunks = 3; */
        if (message.chunks !== 0)
            writer.tag(3, WireType.Varint).uint32(message.chunks);
        /* bytes hash = 4; */
        if (message.hash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.hash);
        /* bytes metadata = 5; */
        if (message.metadata.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tendermint.abci.Snapshot
 */
export const Snapshot = new Snapshot$Type();
/**
 * @generated ServiceType for protobuf service tendermint.abci.ABCIApplication
 */
export const ABCIApplication = new ServiceType("tendermint.abci.ABCIApplication", [
    { name: "Echo", options: {}, I: RequestEcho, O: ResponseEcho },
    { name: "Flush", options: {}, I: RequestFlush, O: ResponseFlush },
    { name: "Info", options: {}, I: RequestInfo, O: ResponseInfo },
    { name: "SetOption", options: {}, I: RequestSetOption, O: ResponseSetOption },
    { name: "DeliverTx", options: {}, I: RequestDeliverTx, O: ResponseDeliverTx },
    { name: "CheckTx", options: {}, I: RequestCheckTx, O: ResponseCheckTx },
    { name: "Query", options: {}, I: RequestQuery, O: ResponseQuery },
    { name: "Commit", options: {}, I: RequestCommit, O: ResponseCommit },
    { name: "InitChain", options: {}, I: RequestInitChain, O: ResponseInitChain },
    { name: "BeginBlock", options: {}, I: RequestBeginBlock, O: ResponseBeginBlock },
    { name: "EndBlock", options: {}, I: RequestEndBlock, O: ResponseEndBlock },
    { name: "ListSnapshots", options: {}, I: RequestListSnapshots, O: ResponseListSnapshots },
    { name: "OfferSnapshot", options: {}, I: RequestOfferSnapshot, O: ResponseOfferSnapshot },
    { name: "LoadSnapshotChunk", options: {}, I: RequestLoadSnapshotChunk, O: ResponseLoadSnapshotChunk },
    { name: "ApplySnapshotChunk", options: {}, I: RequestApplySnapshotChunk, O: ResponseApplySnapshotChunk }
]);
