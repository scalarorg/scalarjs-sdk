// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "tendermint/crypto/proof.proto" (package "tendermint.crypto", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message tendermint.crypto.Proof
 */
export interface Proof {
    /**
     * @generated from protobuf field: int64 total = 1;
     */
    total: string;
    /**
     * @generated from protobuf field: int64 index = 2;
     */
    index: string;
    /**
     * @generated from protobuf field: bytes leaf_hash = 3;
     */
    leafHash: Uint8Array;
    /**
     * @generated from protobuf field: repeated bytes aunts = 4;
     */
    aunts: Uint8Array[];
}
/**
 * @generated from protobuf message tendermint.crypto.ValueOp
 */
export interface ValueOp {
    /**
     * Encoded in ProofOp.Key.
     *
     * @generated from protobuf field: bytes key = 1;
     */
    key: Uint8Array;
    /**
     * To encode in ProofOp.Data
     *
     * @generated from protobuf field: tendermint.crypto.Proof proof = 2;
     */
    proof?: Proof;
}
/**
 * @generated from protobuf message tendermint.crypto.DominoOp
 */
export interface DominoOp {
    /**
     * @generated from protobuf field: string key = 1;
     */
    key: string;
    /**
     * @generated from protobuf field: string input = 2;
     */
    input: string;
    /**
     * @generated from protobuf field: string output = 3;
     */
    output: string;
}
/**
 * ProofOp defines an operation used for calculating Merkle root
 * The data could be arbitrary format, providing nessecary data
 * for example neighbouring node hash
 *
 * @generated from protobuf message tendermint.crypto.ProofOp
 */
export interface ProofOp {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: bytes key = 2;
     */
    key: Uint8Array;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * ProofOps is Merkle proof defined by the list of ProofOps
 *
 * @generated from protobuf message tendermint.crypto.ProofOps
 */
export interface ProofOps {
    /**
     * @generated from protobuf field: repeated tendermint.crypto.ProofOp ops = 1;
     */
    ops: ProofOp[];
}
declare class Proof$Type extends MessageType<Proof> {
    constructor();
    create(value?: PartialMessage<Proof>): Proof;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Proof): Proof;
    internalBinaryWrite(message: Proof, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message tendermint.crypto.Proof
 */
export declare const Proof: Proof$Type;
declare class ValueOp$Type extends MessageType<ValueOp> {
    constructor();
    create(value?: PartialMessage<ValueOp>): ValueOp;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValueOp): ValueOp;
    internalBinaryWrite(message: ValueOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message tendermint.crypto.ValueOp
 */
export declare const ValueOp: ValueOp$Type;
declare class DominoOp$Type extends MessageType<DominoOp> {
    constructor();
    create(value?: PartialMessage<DominoOp>): DominoOp;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DominoOp): DominoOp;
    internalBinaryWrite(message: DominoOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message tendermint.crypto.DominoOp
 */
export declare const DominoOp: DominoOp$Type;
declare class ProofOp$Type extends MessageType<ProofOp> {
    constructor();
    create(value?: PartialMessage<ProofOp>): ProofOp;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProofOp): ProofOp;
    internalBinaryWrite(message: ProofOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message tendermint.crypto.ProofOp
 */
export declare const ProofOp: ProofOp$Type;
declare class ProofOps$Type extends MessageType<ProofOps> {
    constructor();
    create(value?: PartialMessage<ProofOps>): ProofOps;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProofOps): ProofOps;
    internalBinaryWrite(message: ProofOps, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message tendermint.crypto.ProofOps
 */
export declare const ProofOps: ProofOps$Type;
export {};
