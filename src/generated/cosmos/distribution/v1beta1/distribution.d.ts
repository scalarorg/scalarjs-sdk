// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "cosmos/distribution/v1beta1/distribution.proto" (package "cosmos.distribution.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../base/v1beta1/coin";
import { DecCoin } from "../../base/v1beta1/coin";
/**
 * Params defines the set of params for the distribution module.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.Params
 */
export interface Params {
    /**
     * @generated from protobuf field: string community_tax = 1;
     */
    communityTax: string;
    /**
     * @generated from protobuf field: string base_proposer_reward = 2;
     */
    baseProposerReward: string;
    /**
     * @generated from protobuf field: string bonus_proposer_reward = 3;
     */
    bonusProposerReward: string;
    /**
     * @generated from protobuf field: bool withdraw_addr_enabled = 4;
     */
    withdrawAddrEnabled: boolean;
}
/**
 * ValidatorHistoricalRewards represents historical rewards for a validator.
 * Height is implicit within the store key.
 * Cumulative reward ratio is the sum from the zeroeth period
 * until this period of rewards / tokens, per the spec.
 * The reference count indicates the number of objects
 * which might need to reference this historical entry at any point.
 * ReferenceCount =
 *    number of outstanding delegations which ended the associated period (and
 *    might need to read that record)
 *  + number of slashes which ended the associated period (and might need to
 *  read that record)
 *  + one per validator for the zeroeth period, set on initialization
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.ValidatorHistoricalRewards
 */
export interface ValidatorHistoricalRewards {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin cumulative_reward_ratio = 1;
     */
    cumulativeRewardRatio: DecCoin[];
    /**
     * @generated from protobuf field: uint32 reference_count = 2;
     */
    referenceCount: number;
}
/**
 * ValidatorCurrentRewards represents current rewards and current
 * period for a validator kept as a running counter and incremented
 * each block as long as the validator's tokens remain constant.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.ValidatorCurrentRewards
 */
export interface ValidatorCurrentRewards {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin rewards = 1;
     */
    rewards: DecCoin[];
    /**
     * @generated from protobuf field: uint64 period = 2;
     */
    period: string;
}
/**
 * ValidatorAccumulatedCommission represents accumulated commission
 * for a validator kept as a running counter, can be withdrawn at any time.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.ValidatorAccumulatedCommission
 */
export interface ValidatorAccumulatedCommission {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin commission = 1;
     */
    commission: DecCoin[];
}
/**
 * ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
 * for a validator inexpensive to track, allows simple sanity checks.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.ValidatorOutstandingRewards
 */
export interface ValidatorOutstandingRewards {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin rewards = 1;
     */
    rewards: DecCoin[];
}
/**
 * ValidatorSlashEvent represents a validator slash event.
 * Height is implicit within the store key.
 * This is needed to calculate appropriate amount of staking tokens
 * for delegations which are withdrawn after a slash has occurred.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.ValidatorSlashEvent
 */
export interface ValidatorSlashEvent {
    /**
     * @generated from protobuf field: uint64 validator_period = 1;
     */
    validatorPeriod: string;
    /**
     * @generated from protobuf field: string fraction = 2;
     */
    fraction: string;
}
/**
 * ValidatorSlashEvents is a collection of ValidatorSlashEvent messages.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.ValidatorSlashEvents
 */
export interface ValidatorSlashEvents {
    /**
     * @generated from protobuf field: repeated cosmos.distribution.v1beta1.ValidatorSlashEvent validator_slash_events = 1;
     */
    validatorSlashEvents: ValidatorSlashEvent[];
}
/**
 * FeePool is the global fee pool for distribution.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.FeePool
 */
export interface FeePool {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin community_pool = 1;
     */
    communityPool: DecCoin[];
}
/**
 * CommunityPoolSpendProposal details a proposal for use of community funds,
 * together with how many coins are proposed to be spent, and to which
 * recipient account.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.CommunityPoolSpendProposal
 */
export interface CommunityPoolSpendProposal {
    /**
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: string recipient = 3;
     */
    recipient: string;
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin amount = 4;
     */
    amount: Coin[];
}
/**
 * DelegatorStartingInfo represents the starting info for a delegator reward
 * period. It tracks the previous validator period, the delegation's amount of
 * staking token, and the creation height (to check later on if any slashes have
 * occurred). NOTE: Even though validators are slashed to whole staking tokens,
 * the delegators within the validator may be left with less than a full token,
 * thus sdk.Dec is used.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.DelegatorStartingInfo
 */
export interface DelegatorStartingInfo {
    /**
     * @generated from protobuf field: uint64 previous_period = 1;
     */
    previousPeriod: string;
    /**
     * @generated from protobuf field: string stake = 2;
     */
    stake: string;
    /**
     * @generated from protobuf field: uint64 height = 3;
     */
    height: string;
}
/**
 * DelegationDelegatorReward represents the properties
 * of a delegator's delegation reward.
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.DelegationDelegatorReward
 */
export interface DelegationDelegatorReward {
    /**
     * @generated from protobuf field: string validator_address = 1;
     */
    validatorAddress: string;
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.DecCoin reward = 2;
     */
    reward: DecCoin[];
}
/**
 * CommunityPoolSpendProposalWithDeposit defines a CommunityPoolSpendProposal
 * with a deposit
 *
 * @generated from protobuf message cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit
 */
export interface CommunityPoolSpendProposalWithDeposit {
    /**
     * @generated from protobuf field: string title = 1;
     */
    title: string;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: string recipient = 3;
     */
    recipient: string;
    /**
     * @generated from protobuf field: string amount = 4;
     */
    amount: string;
    /**
     * @generated from protobuf field: string deposit = 5;
     */
    deposit: string;
}
declare class Params$Type extends MessageType<Params> {
    constructor();
    create(value?: PartialMessage<Params>): Params;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Params): Params;
    internalBinaryWrite(message: Params, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.Params
 */
export declare const Params: Params$Type;
declare class ValidatorHistoricalRewards$Type extends MessageType<ValidatorHistoricalRewards> {
    constructor();
    create(value?: PartialMessage<ValidatorHistoricalRewards>): ValidatorHistoricalRewards;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorHistoricalRewards): ValidatorHistoricalRewards;
    internalBinaryWrite(message: ValidatorHistoricalRewards, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.ValidatorHistoricalRewards
 */
export declare const ValidatorHistoricalRewards: ValidatorHistoricalRewards$Type;
declare class ValidatorCurrentRewards$Type extends MessageType<ValidatorCurrentRewards> {
    constructor();
    create(value?: PartialMessage<ValidatorCurrentRewards>): ValidatorCurrentRewards;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorCurrentRewards): ValidatorCurrentRewards;
    internalBinaryWrite(message: ValidatorCurrentRewards, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.ValidatorCurrentRewards
 */
export declare const ValidatorCurrentRewards: ValidatorCurrentRewards$Type;
declare class ValidatorAccumulatedCommission$Type extends MessageType<ValidatorAccumulatedCommission> {
    constructor();
    create(value?: PartialMessage<ValidatorAccumulatedCommission>): ValidatorAccumulatedCommission;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorAccumulatedCommission): ValidatorAccumulatedCommission;
    internalBinaryWrite(message: ValidatorAccumulatedCommission, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.ValidatorAccumulatedCommission
 */
export declare const ValidatorAccumulatedCommission: ValidatorAccumulatedCommission$Type;
declare class ValidatorOutstandingRewards$Type extends MessageType<ValidatorOutstandingRewards> {
    constructor();
    create(value?: PartialMessage<ValidatorOutstandingRewards>): ValidatorOutstandingRewards;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorOutstandingRewards): ValidatorOutstandingRewards;
    internalBinaryWrite(message: ValidatorOutstandingRewards, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.ValidatorOutstandingRewards
 */
export declare const ValidatorOutstandingRewards: ValidatorOutstandingRewards$Type;
declare class ValidatorSlashEvent$Type extends MessageType<ValidatorSlashEvent> {
    constructor();
    create(value?: PartialMessage<ValidatorSlashEvent>): ValidatorSlashEvent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorSlashEvent): ValidatorSlashEvent;
    internalBinaryWrite(message: ValidatorSlashEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.ValidatorSlashEvent
 */
export declare const ValidatorSlashEvent: ValidatorSlashEvent$Type;
declare class ValidatorSlashEvents$Type extends MessageType<ValidatorSlashEvents> {
    constructor();
    create(value?: PartialMessage<ValidatorSlashEvents>): ValidatorSlashEvents;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidatorSlashEvents): ValidatorSlashEvents;
    internalBinaryWrite(message: ValidatorSlashEvents, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.ValidatorSlashEvents
 */
export declare const ValidatorSlashEvents: ValidatorSlashEvents$Type;
declare class FeePool$Type extends MessageType<FeePool> {
    constructor();
    create(value?: PartialMessage<FeePool>): FeePool;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeePool): FeePool;
    internalBinaryWrite(message: FeePool, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.FeePool
 */
export declare const FeePool: FeePool$Type;
declare class CommunityPoolSpendProposal$Type extends MessageType<CommunityPoolSpendProposal> {
    constructor();
    create(value?: PartialMessage<CommunityPoolSpendProposal>): CommunityPoolSpendProposal;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommunityPoolSpendProposal): CommunityPoolSpendProposal;
    internalBinaryWrite(message: CommunityPoolSpendProposal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.CommunityPoolSpendProposal
 */
export declare const CommunityPoolSpendProposal: CommunityPoolSpendProposal$Type;
declare class DelegatorStartingInfo$Type extends MessageType<DelegatorStartingInfo> {
    constructor();
    create(value?: PartialMessage<DelegatorStartingInfo>): DelegatorStartingInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DelegatorStartingInfo): DelegatorStartingInfo;
    internalBinaryWrite(message: DelegatorStartingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.DelegatorStartingInfo
 */
export declare const DelegatorStartingInfo: DelegatorStartingInfo$Type;
declare class DelegationDelegatorReward$Type extends MessageType<DelegationDelegatorReward> {
    constructor();
    create(value?: PartialMessage<DelegationDelegatorReward>): DelegationDelegatorReward;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DelegationDelegatorReward): DelegationDelegatorReward;
    internalBinaryWrite(message: DelegationDelegatorReward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.DelegationDelegatorReward
 */
export declare const DelegationDelegatorReward: DelegationDelegatorReward$Type;
declare class CommunityPoolSpendProposalWithDeposit$Type extends MessageType<CommunityPoolSpendProposalWithDeposit> {
    constructor();
    create(value?: PartialMessage<CommunityPoolSpendProposalWithDeposit>): CommunityPoolSpendProposalWithDeposit;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommunityPoolSpendProposalWithDeposit): CommunityPoolSpendProposalWithDeposit;
    internalBinaryWrite(message: CommunityPoolSpendProposalWithDeposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit
 */
export declare const CommunityPoolSpendProposalWithDeposit: CommunityPoolSpendProposalWithDeposit$Type;
export {};
