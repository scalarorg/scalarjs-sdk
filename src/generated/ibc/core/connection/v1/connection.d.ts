// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "ibc/core/connection/v1/connection.proto" (package "ibc.core.connection.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MerklePrefix } from "../../commitment/v1/commitment";
/**
 * ConnectionEnd defines a stateful object on a chain connected to another
 * separate one.
 * NOTE: there must only be 2 defined ConnectionEnds to establish
 * a connection between two chains.
 *
 * @generated from protobuf message ibc.core.connection.v1.ConnectionEnd
 */
export interface ConnectionEnd {
    /**
     * client associated with this connection.
     *
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection.
     *
     * @generated from protobuf field: repeated ibc.core.connection.v1.Version versions = 2;
     */
    versions: Version[];
    /**
     * current state of the connection end.
     *
     * @generated from protobuf field: ibc.core.connection.v1.State state = 3;
     */
    state: State;
    /**
     * counterparty chain associated with this connection.
     *
     * @generated from protobuf field: ibc.core.connection.v1.Counterparty counterparty = 4;
     */
    counterparty?: Counterparty;
    /**
     * delay period that must pass before a consensus state can be used for
     * packet-verification NOTE: delay period logic is only implemented by some
     * clients.
     *
     * @generated from protobuf field: uint64 delay_period = 5;
     */
    delayPeriod: string;
}
/**
 * IdentifiedConnection defines a connection with additional connection
 * identifier field.
 *
 * @generated from protobuf message ibc.core.connection.v1.IdentifiedConnection
 */
export interface IdentifiedConnection {
    /**
     * connection identifier.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * client associated with this connection.
     *
     * @generated from protobuf field: string client_id = 2;
     */
    clientId: string;
    /**
     * IBC version which can be utilised to determine encodings or protocols for
     * channels or packets utilising this connection
     *
     * @generated from protobuf field: repeated ibc.core.connection.v1.Version versions = 3;
     */
    versions: Version[];
    /**
     * current state of the connection end.
     *
     * @generated from protobuf field: ibc.core.connection.v1.State state = 4;
     */
    state: State;
    /**
     * counterparty chain associated with this connection.
     *
     * @generated from protobuf field: ibc.core.connection.v1.Counterparty counterparty = 5;
     */
    counterparty?: Counterparty;
    /**
     * delay period associated with this connection.
     *
     * @generated from protobuf field: uint64 delay_period = 6;
     */
    delayPeriod: string;
}
/**
 * Counterparty defines the counterparty chain associated with a connection end.
 *
 * @generated from protobuf message ibc.core.connection.v1.Counterparty
 */
export interface Counterparty {
    /**
     * identifies the client on the counterparty chain associated with a given
     * connection.
     *
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * identifies the connection end on the counterparty chain associated with a
     * given connection.
     *
     * @generated from protobuf field: string connection_id = 2;
     */
    connectionId: string;
    /**
     * commitment merkle prefix of the counterparty chain.
     *
     * @generated from protobuf field: ibc.core.commitment.v1.MerklePrefix prefix = 3;
     */
    prefix?: MerklePrefix;
}
/**
 * ClientPaths define all the connection paths for a client state.
 *
 * @generated from protobuf message ibc.core.connection.v1.ClientPaths
 */
export interface ClientPaths {
    /**
     * list of connection paths
     *
     * @generated from protobuf field: repeated string paths = 1;
     */
    paths: string[];
}
/**
 * ConnectionPaths define all the connection paths for a given client state.
 *
 * @generated from protobuf message ibc.core.connection.v1.ConnectionPaths
 */
export interface ConnectionPaths {
    /**
     * client state unique identifier
     *
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * list of connection paths
     *
     * @generated from protobuf field: repeated string paths = 2;
     */
    paths: string[];
}
/**
 * Version defines the versioning scheme used to negotiate the IBC verison in
 * the connection handshake.
 *
 * @generated from protobuf message ibc.core.connection.v1.Version
 */
export interface Version {
    /**
     * unique version identifier
     *
     * @generated from protobuf field: string identifier = 1;
     */
    identifier: string;
    /**
     * list of features compatible with the specified identifier
     *
     * @generated from protobuf field: repeated string features = 2;
     */
    features: string[];
}
/**
 * Params defines the set of Connection parameters.
 *
 * @generated from protobuf message ibc.core.connection.v1.Params
 */
export interface Params {
    /**
     * maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the
     * largest amount of time that the chain might reasonably take to produce the next block under normal operating
     * conditions. A safe choice is 3-5x the expected time per block.
     *
     * @generated from protobuf field: uint64 max_expected_time_per_block = 1;
     */
    maxExpectedTimePerBlock: string;
}
/**
 * State defines if a connection is in one of the following states:
 * INIT, TRYOPEN, OPEN or UNINITIALIZED.
 *
 * @generated from protobuf enum ibc.core.connection.v1.State
 */
export declare enum State {
    /**
     * Default State
     *
     * @generated from protobuf enum value: STATE_UNINITIALIZED_UNSPECIFIED = 0;
     */
    UNINITIALIZED_UNSPECIFIED = 0,
    /**
     * A connection end has just started the opening handshake.
     *
     * @generated from protobuf enum value: STATE_INIT = 1;
     */
    INIT = 1,
    /**
     * A connection end has acknowledged the handshake step on the counterparty
     * chain.
     *
     * @generated from protobuf enum value: STATE_TRYOPEN = 2;
     */
    TRYOPEN = 2,
    /**
     * A connection end has completed the handshake.
     *
     * @generated from protobuf enum value: STATE_OPEN = 3;
     */
    OPEN = 3
}
declare class ConnectionEnd$Type extends MessageType<ConnectionEnd> {
    constructor();
    create(value?: PartialMessage<ConnectionEnd>): ConnectionEnd;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionEnd): ConnectionEnd;
    internalBinaryWrite(message: ConnectionEnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.ConnectionEnd
 */
export declare const ConnectionEnd: ConnectionEnd$Type;
declare class IdentifiedConnection$Type extends MessageType<IdentifiedConnection> {
    constructor();
    create(value?: PartialMessage<IdentifiedConnection>): IdentifiedConnection;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdentifiedConnection): IdentifiedConnection;
    internalBinaryWrite(message: IdentifiedConnection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.IdentifiedConnection
 */
export declare const IdentifiedConnection: IdentifiedConnection$Type;
declare class Counterparty$Type extends MessageType<Counterparty> {
    constructor();
    create(value?: PartialMessage<Counterparty>): Counterparty;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Counterparty): Counterparty;
    internalBinaryWrite(message: Counterparty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.Counterparty
 */
export declare const Counterparty: Counterparty$Type;
declare class ClientPaths$Type extends MessageType<ClientPaths> {
    constructor();
    create(value?: PartialMessage<ClientPaths>): ClientPaths;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientPaths): ClientPaths;
    internalBinaryWrite(message: ClientPaths, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.ClientPaths
 */
export declare const ClientPaths: ClientPaths$Type;
declare class ConnectionPaths$Type extends MessageType<ConnectionPaths> {
    constructor();
    create(value?: PartialMessage<ConnectionPaths>): ConnectionPaths;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionPaths): ConnectionPaths;
    internalBinaryWrite(message: ConnectionPaths, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.ConnectionPaths
 */
export declare const ConnectionPaths: ConnectionPaths$Type;
declare class Version$Type extends MessageType<Version> {
    constructor();
    create(value?: PartialMessage<Version>): Version;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Version): Version;
    internalBinaryWrite(message: Version, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.Version
 */
export declare const Version: Version$Type;
declare class Params$Type extends MessageType<Params> {
    constructor();
    create(value?: PartialMessage<Params>): Params;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Params): Params;
    internalBinaryWrite(message: Params, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.core.connection.v1.Params
 */
export declare const Params: Params$Type;
export {};
