// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "ibc/lightclients/solomachine/v2/solomachine.proto" (package "ibc.lightclients.solomachine.v2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Channel } from "../../../core/channel/v1/channel";
import { ConnectionEnd } from "../../../core/connection/v1/connection";
import { Any } from "../../../../google/protobuf/any";
/**
 * ClientState defines a solo machine client that tracks the current consensus
 * state and if the client is frozen.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.ClientState
 */
export interface ClientState {
    /**
     * latest sequence of the client state
     *
     * @generated from protobuf field: uint64 sequence = 1;
     */
    sequence: string;
    /**
     * frozen sequence of the solo machine
     *
     * @generated from protobuf field: bool is_frozen = 2;
     */
    isFrozen: boolean;
    /**
     * @generated from protobuf field: ibc.lightclients.solomachine.v2.ConsensusState consensus_state = 3;
     */
    consensusState?: ConsensusState;
    /**
     * when set to true, will allow governance to update a solo machine client.
     * The client will be unfrozen if it is frozen.
     *
     * @generated from protobuf field: bool allow_update_after_proposal = 4;
     */
    allowUpdateAfterProposal: boolean;
}
/**
 * ConsensusState defines a solo machine consensus state. The sequence of a
 * consensus state is contained in the "height" key used in storing the
 * consensus state.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.ConsensusState
 */
export interface ConsensusState {
    /**
     * public key of the solo machine
     *
     * @generated from protobuf field: google.protobuf.Any public_key = 1;
     */
    publicKey?: Any;
    /**
     * diversifier allows the same public key to be re-used across different solo
     * machine clients (potentially on different chains) without being considered
     * misbehaviour.
     *
     * @generated from protobuf field: string diversifier = 2;
     */
    diversifier: string;
    /**
     * @generated from protobuf field: uint64 timestamp = 3;
     */
    timestamp: string;
}
/**
 * Header defines a solo machine consensus header
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.Header
 */
export interface Header {
    /**
     * sequence to update solo machine public key at
     *
     * @generated from protobuf field: uint64 sequence = 1;
     */
    sequence: string;
    /**
     * @generated from protobuf field: uint64 timestamp = 2;
     */
    timestamp: string;
    /**
     * @generated from protobuf field: bytes signature = 3;
     */
    signature: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Any new_public_key = 4;
     */
    newPublicKey?: Any;
    /**
     * @generated from protobuf field: string new_diversifier = 5;
     */
    newDiversifier: string;
}
/**
 * Misbehaviour defines misbehaviour for a solo machine which consists
 * of a sequence and two signatures over different messages at that sequence.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.Misbehaviour
 */
export interface Misbehaviour {
    /**
     * @generated from protobuf field: string client_id = 1;
     */
    clientId: string;
    /**
     * @generated from protobuf field: uint64 sequence = 2;
     */
    sequence: string;
    /**
     * @generated from protobuf field: ibc.lightclients.solomachine.v2.SignatureAndData signature_one = 3;
     */
    signatureOne?: SignatureAndData;
    /**
     * @generated from protobuf field: ibc.lightclients.solomachine.v2.SignatureAndData signature_two = 4;
     */
    signatureTwo?: SignatureAndData;
}
/**
 * SignatureAndData contains a signature and the data signed over to create that
 * signature.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.SignatureAndData
 */
export interface SignatureAndData {
    /**
     * @generated from protobuf field: bytes signature = 1;
     */
    signature: Uint8Array;
    /**
     * @generated from protobuf field: ibc.lightclients.solomachine.v2.DataType data_type = 2;
     */
    dataType: DataType;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: uint64 timestamp = 4;
     */
    timestamp: string;
}
/**
 * TimestampedSignatureData contains the signature data and the timestamp of the
 * signature.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.TimestampedSignatureData
 */
export interface TimestampedSignatureData {
    /**
     * @generated from protobuf field: bytes signature_data = 1;
     */
    signatureData: Uint8Array;
    /**
     * @generated from protobuf field: uint64 timestamp = 2;
     */
    timestamp: string;
}
/**
 * SignBytes defines the signed bytes used for signature verification.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.SignBytes
 */
export interface SignBytes {
    /**
     * @generated from protobuf field: uint64 sequence = 1;
     */
    sequence: string;
    /**
     * @generated from protobuf field: uint64 timestamp = 2;
     */
    timestamp: string;
    /**
     * @generated from protobuf field: string diversifier = 3;
     */
    diversifier: string;
    /**
     * type of the data used
     *
     * @generated from protobuf field: ibc.lightclients.solomachine.v2.DataType data_type = 4;
     */
    dataType: DataType;
    /**
     * marshaled data
     *
     * @generated from protobuf field: bytes data = 5;
     */
    data: Uint8Array;
}
/**
 * HeaderData returns the SignBytes data for update verification.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.HeaderData
 */
export interface HeaderData {
    /**
     * header public key
     *
     * @generated from protobuf field: google.protobuf.Any new_pub_key = 1;
     */
    newPubKey?: Any;
    /**
     * header diversifier
     *
     * @generated from protobuf field: string new_diversifier = 2;
     */
    newDiversifier: string;
}
/**
 * ClientStateData returns the SignBytes data for client state verification.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.ClientStateData
 */
export interface ClientStateData {
    /**
     * @generated from protobuf field: bytes path = 1;
     */
    path: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Any client_state = 2;
     */
    clientState?: Any;
}
/**
 * ConsensusStateData returns the SignBytes data for consensus state
 * verification.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.ConsensusStateData
 */
export interface ConsensusStateData {
    /**
     * @generated from protobuf field: bytes path = 1;
     */
    path: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Any consensus_state = 2;
     */
    consensusState?: Any;
}
/**
 * ConnectionStateData returns the SignBytes data for connection state
 * verification.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.ConnectionStateData
 */
export interface ConnectionStateData {
    /**
     * @generated from protobuf field: bytes path = 1;
     */
    path: Uint8Array;
    /**
     * @generated from protobuf field: ibc.core.connection.v1.ConnectionEnd connection = 2;
     */
    connection?: ConnectionEnd;
}
/**
 * ChannelStateData returns the SignBytes data for channel state
 * verification.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.ChannelStateData
 */
export interface ChannelStateData {
    /**
     * @generated from protobuf field: bytes path = 1;
     */
    path: Uint8Array;
    /**
     * @generated from protobuf field: ibc.core.channel.v1.Channel channel = 2;
     */
    channel?: Channel;
}
/**
 * PacketCommitmentData returns the SignBytes data for packet commitment
 * verification.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.PacketCommitmentData
 */
export interface PacketCommitmentData {
    /**
     * @generated from protobuf field: bytes path = 1;
     */
    path: Uint8Array;
    /**
     * @generated from protobuf field: bytes commitment = 2;
     */
    commitment: Uint8Array;
}
/**
 * PacketAcknowledgementData returns the SignBytes data for acknowledgement
 * verification.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.PacketAcknowledgementData
 */
export interface PacketAcknowledgementData {
    /**
     * @generated from protobuf field: bytes path = 1;
     */
    path: Uint8Array;
    /**
     * @generated from protobuf field: bytes acknowledgement = 2;
     */
    acknowledgement: Uint8Array;
}
/**
 * PacketReceiptAbsenceData returns the SignBytes data for
 * packet receipt absence verification.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.PacketReceiptAbsenceData
 */
export interface PacketReceiptAbsenceData {
    /**
     * @generated from protobuf field: bytes path = 1;
     */
    path: Uint8Array;
}
/**
 * NextSequenceRecvData returns the SignBytes data for verification of the next
 * sequence to be received.
 *
 * @generated from protobuf message ibc.lightclients.solomachine.v2.NextSequenceRecvData
 */
export interface NextSequenceRecvData {
    /**
     * @generated from protobuf field: bytes path = 1;
     */
    path: Uint8Array;
    /**
     * @generated from protobuf field: uint64 next_seq_recv = 2;
     */
    nextSeqRecv: string;
}
/**
 * DataType defines the type of solo machine proof being created. This is done
 * to preserve uniqueness of different data sign byte encodings.
 *
 * @generated from protobuf enum ibc.lightclients.solomachine.v2.DataType
 */
export declare enum DataType {
    /**
     * Default State
     *
     * @generated from protobuf enum value: DATA_TYPE_UNINITIALIZED_UNSPECIFIED = 0;
     */
    UNINITIALIZED_UNSPECIFIED = 0,
    /**
     * Data type for client state verification
     *
     * @generated from protobuf enum value: DATA_TYPE_CLIENT_STATE = 1;
     */
    CLIENT_STATE = 1,
    /**
     * Data type for consensus state verification
     *
     * @generated from protobuf enum value: DATA_TYPE_CONSENSUS_STATE = 2;
     */
    CONSENSUS_STATE = 2,
    /**
     * Data type for connection state verification
     *
     * @generated from protobuf enum value: DATA_TYPE_CONNECTION_STATE = 3;
     */
    CONNECTION_STATE = 3,
    /**
     * Data type for channel state verification
     *
     * @generated from protobuf enum value: DATA_TYPE_CHANNEL_STATE = 4;
     */
    CHANNEL_STATE = 4,
    /**
     * Data type for packet commitment verification
     *
     * @generated from protobuf enum value: DATA_TYPE_PACKET_COMMITMENT = 5;
     */
    PACKET_COMMITMENT = 5,
    /**
     * Data type for packet acknowledgement verification
     *
     * @generated from protobuf enum value: DATA_TYPE_PACKET_ACKNOWLEDGEMENT = 6;
     */
    PACKET_ACKNOWLEDGEMENT = 6,
    /**
     * Data type for packet receipt absence verification
     *
     * @generated from protobuf enum value: DATA_TYPE_PACKET_RECEIPT_ABSENCE = 7;
     */
    PACKET_RECEIPT_ABSENCE = 7,
    /**
     * Data type for next sequence recv verification
     *
     * @generated from protobuf enum value: DATA_TYPE_NEXT_SEQUENCE_RECV = 8;
     */
    NEXT_SEQUENCE_RECV = 8,
    /**
     * Data type for header verification
     *
     * @generated from protobuf enum value: DATA_TYPE_HEADER = 9;
     */
    HEADER = 9
}
declare class ClientState$Type extends MessageType<ClientState> {
    constructor();
    create(value?: PartialMessage<ClientState>): ClientState;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientState): ClientState;
    internalBinaryWrite(message: ClientState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.ClientState
 */
export declare const ClientState: ClientState$Type;
declare class ConsensusState$Type extends MessageType<ConsensusState> {
    constructor();
    create(value?: PartialMessage<ConsensusState>): ConsensusState;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsensusState): ConsensusState;
    internalBinaryWrite(message: ConsensusState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.ConsensusState
 */
export declare const ConsensusState: ConsensusState$Type;
declare class Header$Type extends MessageType<Header> {
    constructor();
    create(value?: PartialMessage<Header>): Header;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Header): Header;
    internalBinaryWrite(message: Header, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.Header
 */
export declare const Header: Header$Type;
declare class Misbehaviour$Type extends MessageType<Misbehaviour> {
    constructor();
    create(value?: PartialMessage<Misbehaviour>): Misbehaviour;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Misbehaviour): Misbehaviour;
    internalBinaryWrite(message: Misbehaviour, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.Misbehaviour
 */
export declare const Misbehaviour: Misbehaviour$Type;
declare class SignatureAndData$Type extends MessageType<SignatureAndData> {
    constructor();
    create(value?: PartialMessage<SignatureAndData>): SignatureAndData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignatureAndData): SignatureAndData;
    internalBinaryWrite(message: SignatureAndData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.SignatureAndData
 */
export declare const SignatureAndData: SignatureAndData$Type;
declare class TimestampedSignatureData$Type extends MessageType<TimestampedSignatureData> {
    constructor();
    create(value?: PartialMessage<TimestampedSignatureData>): TimestampedSignatureData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimestampedSignatureData): TimestampedSignatureData;
    internalBinaryWrite(message: TimestampedSignatureData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.TimestampedSignatureData
 */
export declare const TimestampedSignatureData: TimestampedSignatureData$Type;
declare class SignBytes$Type extends MessageType<SignBytes> {
    constructor();
    create(value?: PartialMessage<SignBytes>): SignBytes;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignBytes): SignBytes;
    internalBinaryWrite(message: SignBytes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.SignBytes
 */
export declare const SignBytes: SignBytes$Type;
declare class HeaderData$Type extends MessageType<HeaderData> {
    constructor();
    create(value?: PartialMessage<HeaderData>): HeaderData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeaderData): HeaderData;
    internalBinaryWrite(message: HeaderData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.HeaderData
 */
export declare const HeaderData: HeaderData$Type;
declare class ClientStateData$Type extends MessageType<ClientStateData> {
    constructor();
    create(value?: PartialMessage<ClientStateData>): ClientStateData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientStateData): ClientStateData;
    internalBinaryWrite(message: ClientStateData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.ClientStateData
 */
export declare const ClientStateData: ClientStateData$Type;
declare class ConsensusStateData$Type extends MessageType<ConsensusStateData> {
    constructor();
    create(value?: PartialMessage<ConsensusStateData>): ConsensusStateData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConsensusStateData): ConsensusStateData;
    internalBinaryWrite(message: ConsensusStateData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.ConsensusStateData
 */
export declare const ConsensusStateData: ConsensusStateData$Type;
declare class ConnectionStateData$Type extends MessageType<ConnectionStateData> {
    constructor();
    create(value?: PartialMessage<ConnectionStateData>): ConnectionStateData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConnectionStateData): ConnectionStateData;
    internalBinaryWrite(message: ConnectionStateData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.ConnectionStateData
 */
export declare const ConnectionStateData: ConnectionStateData$Type;
declare class ChannelStateData$Type extends MessageType<ChannelStateData> {
    constructor();
    create(value?: PartialMessage<ChannelStateData>): ChannelStateData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChannelStateData): ChannelStateData;
    internalBinaryWrite(message: ChannelStateData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.ChannelStateData
 */
export declare const ChannelStateData: ChannelStateData$Type;
declare class PacketCommitmentData$Type extends MessageType<PacketCommitmentData> {
    constructor();
    create(value?: PartialMessage<PacketCommitmentData>): PacketCommitmentData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PacketCommitmentData): PacketCommitmentData;
    internalBinaryWrite(message: PacketCommitmentData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.PacketCommitmentData
 */
export declare const PacketCommitmentData: PacketCommitmentData$Type;
declare class PacketAcknowledgementData$Type extends MessageType<PacketAcknowledgementData> {
    constructor();
    create(value?: PartialMessage<PacketAcknowledgementData>): PacketAcknowledgementData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PacketAcknowledgementData): PacketAcknowledgementData;
    internalBinaryWrite(message: PacketAcknowledgementData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.PacketAcknowledgementData
 */
export declare const PacketAcknowledgementData: PacketAcknowledgementData$Type;
declare class PacketReceiptAbsenceData$Type extends MessageType<PacketReceiptAbsenceData> {
    constructor();
    create(value?: PartialMessage<PacketReceiptAbsenceData>): PacketReceiptAbsenceData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PacketReceiptAbsenceData): PacketReceiptAbsenceData;
    internalBinaryWrite(message: PacketReceiptAbsenceData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.PacketReceiptAbsenceData
 */
export declare const PacketReceiptAbsenceData: PacketReceiptAbsenceData$Type;
declare class NextSequenceRecvData$Type extends MessageType<NextSequenceRecvData> {
    constructor();
    create(value?: PartialMessage<NextSequenceRecvData>): NextSequenceRecvData;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NextSequenceRecvData): NextSequenceRecvData;
    internalBinaryWrite(message: NextSequenceRecvData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message ibc.lightclients.solomachine.v2.NextSequenceRecvData
 */
export declare const NextSequenceRecvData: NextSequenceRecvData$Type;
export {};
