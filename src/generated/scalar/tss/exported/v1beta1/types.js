// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "scalar/tss/exported/v1beta1/types.proto" (package "scalar.tss.exported.v1beta1", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Threshold } from "../../../utils/v1beta1/threshold";
/**
 * @generated from protobuf enum scalar.tss.exported.v1beta1.KeyRole
 */
export var KeyRole;
(function (KeyRole) {
    /**
     * @generated from protobuf enum value: KEY_ROLE_UNSPECIFIED = 0;
     */
    KeyRole[KeyRole["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: KEY_ROLE_MASTER_KEY = 1;
     */
    KeyRole[KeyRole["MASTER_KEY"] = 1] = "MASTER_KEY";
    /**
     * @generated from protobuf enum value: KEY_ROLE_SECONDARY_KEY = 2;
     */
    KeyRole[KeyRole["SECONDARY_KEY"] = 2] = "SECONDARY_KEY";
    /**
     * @generated from protobuf enum value: KEY_ROLE_EXTERNAL_KEY = 3;
     */
    KeyRole[KeyRole["EXTERNAL_KEY"] = 3] = "EXTERNAL_KEY";
})(KeyRole || (KeyRole = {}));
/**
 * @generated from protobuf enum scalar.tss.exported.v1beta1.KeyType
 */
export var KeyType;
(function (KeyType) {
    /**
     * @generated from protobuf enum value: KEY_TYPE_UNSPECIFIED = 0;
     */
    KeyType[KeyType["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: KEY_TYPE_NONE = 1;
     */
    KeyType[KeyType["NONE"] = 1] = "NONE";
    /**
     * @generated from protobuf enum value: KEY_TYPE_THRESHOLD = 2;
     */
    KeyType[KeyType["THRESHOLD"] = 2] = "THRESHOLD";
    /**
     * @generated from protobuf enum value: KEY_TYPE_MULTISIG = 3;
     */
    KeyType[KeyType["MULTISIG"] = 3] = "MULTISIG";
})(KeyType || (KeyType = {}));
/**
 * @generated from protobuf enum scalar.tss.exported.v1beta1.KeyShareDistributionPolicy
 */
export var KeyShareDistributionPolicy;
(function (KeyShareDistributionPolicy) {
    /**
     * @generated from protobuf enum value: KEY_SHARE_DISTRIBUTION_POLICY_UNSPECIFIED = 0;
     */
    KeyShareDistributionPolicy[KeyShareDistributionPolicy["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: KEY_SHARE_DISTRIBUTION_POLICY_WEIGHTED_BY_STAKE = 1;
     */
    KeyShareDistributionPolicy[KeyShareDistributionPolicy["WEIGHTED_BY_STAKE"] = 1] = "WEIGHTED_BY_STAKE";
    /**
     * @generated from protobuf enum value: KEY_SHARE_DISTRIBUTION_POLICY_ONE_PER_VALIDATOR = 2;
     */
    KeyShareDistributionPolicy[KeyShareDistributionPolicy["ONE_PER_VALIDATOR"] = 2] = "ONE_PER_VALIDATOR";
})(KeyShareDistributionPolicy || (KeyShareDistributionPolicy = {}));
// @generated message type with reflection information, may provide speed optimized methods
class KeyRequirement$Type extends MessageType {
    constructor() {
        super("scalar.tss.exported.v1beta1.KeyRequirement", [
            { no: 1, name: "key_role", kind: "enum", T: () => ["scalar.tss.exported.v1beta1.KeyRole", KeyRole, "KEY_ROLE_"] },
            { no: 2, name: "key_type", kind: "enum", T: () => ["scalar.tss.exported.v1beta1.KeyType", KeyType, "KEY_TYPE_"] },
            { no: 3, name: "min_keygen_threshold", kind: "message", T: () => Threshold, options: { "gogoproto.nullable": false } },
            { no: 4, name: "safety_threshold", kind: "message", T: () => Threshold, options: { "gogoproto.nullable": false } },
            { no: 5, name: "key_share_distribution_policy", kind: "enum", T: () => ["scalar.tss.exported.v1beta1.KeyShareDistributionPolicy", KeyShareDistributionPolicy, "KEY_SHARE_DISTRIBUTION_POLICY_"] },
            { no: 6, name: "max_total_share_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "min_total_share_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "keygen_voting_threshold", kind: "message", T: () => Threshold, options: { "gogoproto.nullable": false } },
            { no: 9, name: "sign_voting_threshold", kind: "message", T: () => Threshold, options: { "gogoproto.nullable": false } },
            { no: 10, name: "keygen_timeout", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 11, name: "sign_timeout", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.keyRole = 0;
        message.keyType = 0;
        message.keyShareDistributionPolicy = 0;
        message.maxTotalShareCount = "0";
        message.minTotalShareCount = "0";
        message.keygenTimeout = "0";
        message.signTimeout = "0";
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* scalar.tss.exported.v1beta1.KeyRole key_role */ 1:
                    message.keyRole = reader.int32();
                    break;
                case /* scalar.tss.exported.v1beta1.KeyType key_type */ 2:
                    message.keyType = reader.int32();
                    break;
                case /* scalar.utils.v1beta1.Threshold min_keygen_threshold */ 3:
                    message.minKeygenThreshold = Threshold.internalBinaryRead(reader, reader.uint32(), options, message.minKeygenThreshold);
                    break;
                case /* scalar.utils.v1beta1.Threshold safety_threshold */ 4:
                    message.safetyThreshold = Threshold.internalBinaryRead(reader, reader.uint32(), options, message.safetyThreshold);
                    break;
                case /* scalar.tss.exported.v1beta1.KeyShareDistributionPolicy key_share_distribution_policy */ 5:
                    message.keyShareDistributionPolicy = reader.int32();
                    break;
                case /* int64 max_total_share_count */ 6:
                    message.maxTotalShareCount = reader.int64().toString();
                    break;
                case /* int64 min_total_share_count */ 7:
                    message.minTotalShareCount = reader.int64().toString();
                    break;
                case /* scalar.utils.v1beta1.Threshold keygen_voting_threshold */ 8:
                    message.keygenVotingThreshold = Threshold.internalBinaryRead(reader, reader.uint32(), options, message.keygenVotingThreshold);
                    break;
                case /* scalar.utils.v1beta1.Threshold sign_voting_threshold */ 9:
                    message.signVotingThreshold = Threshold.internalBinaryRead(reader, reader.uint32(), options, message.signVotingThreshold);
                    break;
                case /* int64 keygen_timeout */ 10:
                    message.keygenTimeout = reader.int64().toString();
                    break;
                case /* int64 sign_timeout */ 11:
                    message.signTimeout = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* scalar.tss.exported.v1beta1.KeyRole key_role = 1; */
        if (message.keyRole !== 0)
            writer.tag(1, WireType.Varint).int32(message.keyRole);
        /* scalar.tss.exported.v1beta1.KeyType key_type = 2; */
        if (message.keyType !== 0)
            writer.tag(2, WireType.Varint).int32(message.keyType);
        /* scalar.utils.v1beta1.Threshold min_keygen_threshold = 3; */
        if (message.minKeygenThreshold)
            Threshold.internalBinaryWrite(message.minKeygenThreshold, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* scalar.utils.v1beta1.Threshold safety_threshold = 4; */
        if (message.safetyThreshold)
            Threshold.internalBinaryWrite(message.safetyThreshold, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* scalar.tss.exported.v1beta1.KeyShareDistributionPolicy key_share_distribution_policy = 5; */
        if (message.keyShareDistributionPolicy !== 0)
            writer.tag(5, WireType.Varint).int32(message.keyShareDistributionPolicy);
        /* int64 max_total_share_count = 6; */
        if (message.maxTotalShareCount !== "0")
            writer.tag(6, WireType.Varint).int64(message.maxTotalShareCount);
        /* int64 min_total_share_count = 7; */
        if (message.minTotalShareCount !== "0")
            writer.tag(7, WireType.Varint).int64(message.minTotalShareCount);
        /* scalar.utils.v1beta1.Threshold keygen_voting_threshold = 8; */
        if (message.keygenVotingThreshold)
            Threshold.internalBinaryWrite(message.keygenVotingThreshold, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* scalar.utils.v1beta1.Threshold sign_voting_threshold = 9; */
        if (message.signVotingThreshold)
            Threshold.internalBinaryWrite(message.signVotingThreshold, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int64 keygen_timeout = 10; */
        if (message.keygenTimeout !== "0")
            writer.tag(10, WireType.Varint).int64(message.keygenTimeout);
        /* int64 sign_timeout = 11; */
        if (message.signTimeout !== "0")
            writer.tag(11, WireType.Varint).int64(message.signTimeout);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalar.tss.exported.v1beta1.KeyRequirement
 */
export const KeyRequirement = new KeyRequirement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SigKeyPair$Type extends MessageType {
    constructor() {
        super("scalar.tss.exported.v1beta1.SigKeyPair", [
            { no: 1, name: "pub_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.pubKey = new Uint8Array(0);
        message.signature = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes pub_key */ 1:
                    message.pubKey = reader.bytes();
                    break;
                case /* bytes signature */ 2:
                    message.signature = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes pub_key = 1; */
        if (message.pubKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.pubKey);
        /* bytes signature = 2; */
        if (message.signature.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalar.tss.exported.v1beta1.SigKeyPair
 */
export const SigKeyPair = new SigKeyPair$Type();
