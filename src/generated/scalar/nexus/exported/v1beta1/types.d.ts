// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "scalar/nexus/exported/v1beta1/types.proto" (package "scalar.nexus.exported.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Coin } from "../../../../cosmos/base/v1beta1/coin";
import { KeyType } from "../../../tss/exported/v1beta1/types";
/**
 * Chain represents the properties of a registered blockchain
 *
 * @generated from protobuf message scalar.nexus.exported.v1beta1.Chain
 */
export interface Chain {
    /**
     * The descriptor of the chain, e.g. "evm|11155111"
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bool supports_foreign_assets = 2;
     */
    supportsForeignAssets: boolean;
    /**
     * @generated from protobuf field: scalar.tss.exported.v1beta1.KeyType key_type = 3;
     */
    keyType: KeyType;
    /**
     * the module has two types: chains and scalarnet
     *
     * @generated from protobuf field: string module = 4;
     */
    module: string;
}
/**
 * CrossChainAddress represents a generalized address on any registered chain
 *
 * @generated from protobuf message scalar.nexus.exported.v1beta1.CrossChainAddress
 */
export interface CrossChainAddress {
    /**
     * @generated from protobuf field: scalar.nexus.exported.v1beta1.Chain chain = 1;
     */
    chain?: Chain;
    /**
     * @generated from protobuf field: string address = 2;
     */
    address: string;
}
/**
 * CrossChainTransfer represents a generalized transfer of some asset to a
 * registered blockchain
 *
 * @generated from protobuf message scalar.nexus.exported.v1beta1.CrossChainTransfer
 */
export interface CrossChainTransfer {
    /**
     * @generated from protobuf field: scalar.nexus.exported.v1beta1.CrossChainAddress recipient = 1;
     */
    recipient?: CrossChainAddress;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin asset = 2;
     */
    asset?: Coin;
    /**
     * @generated from protobuf field: uint64 id = 3;
     */
    id: string;
    /**
     * @generated from protobuf field: scalar.nexus.exported.v1beta1.TransferState state = 4;
     */
    state: TransferState;
}
/**
 * TransferFee represents accumulated fees generated by the network
 *
 * @generated from protobuf message scalar.nexus.exported.v1beta1.TransferFee
 */
export interface TransferFee {
    /**
     * @generated from protobuf field: repeated cosmos.base.v1beta1.Coin coins = 1;
     */
    coins: Coin[];
}
/**
 * @generated from protobuf message scalar.nexus.exported.v1beta1.FeeInfo
 */
export interface FeeInfo {
    /**
     * @generated from protobuf field: string chain = 1;
     */
    chain: string;
    /**
     * @generated from protobuf field: string asset = 2;
     */
    asset: string;
    /**
     * @generated from protobuf field: bytes fee_rate = 3;
     */
    feeRate: Uint8Array;
    /**
     * @generated from protobuf field: bytes min_fee = 4;
     */
    minFee: Uint8Array;
    /**
     * @generated from protobuf field: bytes max_fee = 5;
     */
    maxFee: Uint8Array;
}
/**
 * @generated from protobuf message scalar.nexus.exported.v1beta1.Asset
 */
export interface Asset {
    /**
     * @generated from protobuf field: string denom = 1;
     */
    denom: string;
    /**
     * @generated from protobuf field: bool is_native_asset = 3;
     */
    isNativeAsset: boolean;
}
/**
 * @generated from protobuf message scalar.nexus.exported.v1beta1.GeneralMessage
 */
export interface GeneralMessage {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: scalar.nexus.exported.v1beta1.CrossChainAddress sender = 2;
     */
    sender?: CrossChainAddress;
    /**
     * @generated from protobuf field: scalar.nexus.exported.v1beta1.CrossChainAddress recipient = 3;
     */
    recipient?: CrossChainAddress;
    /**
     * @generated from protobuf field: bytes payload_hash = 4;
     */
    payloadHash: Uint8Array;
    /**
     * @generated from protobuf field: scalar.nexus.exported.v1beta1.GeneralMessage.Status status = 5;
     */
    status: GeneralMessage_Status;
    /**
     * @generated from protobuf field: cosmos.base.v1beta1.Coin asset = 6;
     */
    asset?: Coin;
    /**
     * @generated from protobuf field: bytes source_tx_id = 7;
     */
    sourceTxId: Uint8Array;
    /**
     * @generated from protobuf field: uint64 source_tx_index = 8;
     */
    sourceTxIndex: string;
}
/**
 * @generated from protobuf enum scalar.nexus.exported.v1beta1.GeneralMessage.Status
 */
export declare enum GeneralMessage_Status {
    /**
     * @generated from protobuf enum value: STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STATUS_APPROVED = 1;
     */
    APPROVED = 1,
    /**
     * @generated from protobuf enum value: STATUS_PROCESSING = 2;
     */
    PROCESSING = 2,
    /**
     * @generated from protobuf enum value: STATUS_EXECUTED = 3;
     */
    EXECUTED = 3,
    /**
     * @generated from protobuf enum value: STATUS_FAILED = 4;
     */
    FAILED = 4
}
/**
 * @generated from protobuf message scalar.nexus.exported.v1beta1.WasmMessage
 */
export interface WasmMessage {
    /**
     * @generated from protobuf field: string source_chain = 1;
     */
    sourceChain: string;
    /**
     * @generated from protobuf field: string source_address = 2;
     */
    sourceAddress: string;
    /**
     * @generated from protobuf field: string destination_chain = 3;
     */
    destinationChain: string;
    /**
     * @generated from protobuf field: string destination_address = 4;
     */
    destinationAddress: string;
    /**
     * @generated from protobuf field: bytes payload_hash = 5;
     */
    payloadHash: Uint8Array;
    /**
     * @generated from protobuf field: bytes source_tx_id = 6;
     */
    sourceTxId: Uint8Array;
    /**
     * @generated from protobuf field: uint64 source_tx_index = 7;
     */
    sourceTxIndex: string;
    /**
     * @generated from protobuf field: bytes sender = 8;
     */
    sender: Uint8Array;
    /**
     * @generated from protobuf field: string id = 9;
     */
    id: string;
}
/**
 * @generated from protobuf enum scalar.nexus.exported.v1beta1.TransferState
 */
export declare enum TransferState {
    /**
     * @generated from protobuf enum value: TRANSFER_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TRANSFER_STATE_PENDING = 1;
     */
    PENDING = 1,
    /**
     * @generated from protobuf enum value: TRANSFER_STATE_ARCHIVED = 2;
     */
    ARCHIVED = 2,
    /**
     * @generated from protobuf enum value: TRANSFER_STATE_INSUFFICIENT_AMOUNT = 3;
     */
    INSUFFICIENT_AMOUNT = 3,
    /**
     * @generated from protobuf enum value: TRANSFER_STATE_FAILED = 4;
     */
    FAILED = 4
}
/**
 * @generated from protobuf enum scalar.nexus.exported.v1beta1.TransferDirection
 */
export declare enum TransferDirection {
    /**
     * @generated from protobuf enum value: TRANSFER_DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TRANSFER_DIRECTION_FROM = 1;
     */
    FROM = 1,
    /**
     * @generated from protobuf enum value: TRANSFER_DIRECTION_TO = 2;
     */
    TO = 2
}
declare class Chain$Type extends MessageType<Chain> {
    constructor();
    create(value?: PartialMessage<Chain>): Chain;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Chain): Chain;
    internalBinaryWrite(message: Chain, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message scalar.nexus.exported.v1beta1.Chain
 */
export declare const Chain: Chain$Type;
declare class CrossChainAddress$Type extends MessageType<CrossChainAddress> {
    constructor();
    create(value?: PartialMessage<CrossChainAddress>): CrossChainAddress;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrossChainAddress): CrossChainAddress;
    internalBinaryWrite(message: CrossChainAddress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message scalar.nexus.exported.v1beta1.CrossChainAddress
 */
export declare const CrossChainAddress: CrossChainAddress$Type;
declare class CrossChainTransfer$Type extends MessageType<CrossChainTransfer> {
    constructor();
    create(value?: PartialMessage<CrossChainTransfer>): CrossChainTransfer;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrossChainTransfer): CrossChainTransfer;
    internalBinaryWrite(message: CrossChainTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message scalar.nexus.exported.v1beta1.CrossChainTransfer
 */
export declare const CrossChainTransfer: CrossChainTransfer$Type;
declare class TransferFee$Type extends MessageType<TransferFee> {
    constructor();
    create(value?: PartialMessage<TransferFee>): TransferFee;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransferFee): TransferFee;
    internalBinaryWrite(message: TransferFee, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message scalar.nexus.exported.v1beta1.TransferFee
 */
export declare const TransferFee: TransferFee$Type;
declare class FeeInfo$Type extends MessageType<FeeInfo> {
    constructor();
    create(value?: PartialMessage<FeeInfo>): FeeInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeInfo): FeeInfo;
    internalBinaryWrite(message: FeeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message scalar.nexus.exported.v1beta1.FeeInfo
 */
export declare const FeeInfo: FeeInfo$Type;
declare class Asset$Type extends MessageType<Asset> {
    constructor();
    create(value?: PartialMessage<Asset>): Asset;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Asset): Asset;
    internalBinaryWrite(message: Asset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message scalar.nexus.exported.v1beta1.Asset
 */
export declare const Asset: Asset$Type;
declare class GeneralMessage$Type extends MessageType<GeneralMessage> {
    constructor();
    create(value?: PartialMessage<GeneralMessage>): GeneralMessage;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GeneralMessage): GeneralMessage;
    internalBinaryWrite(message: GeneralMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message scalar.nexus.exported.v1beta1.GeneralMessage
 */
export declare const GeneralMessage: GeneralMessage$Type;
declare class WasmMessage$Type extends MessageType<WasmMessage> {
    constructor();
    create(value?: PartialMessage<WasmMessage>): WasmMessage;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WasmMessage): WasmMessage;
    internalBinaryWrite(message: WasmMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message scalar.nexus.exported.v1beta1.WasmMessage
 */
export declare const WasmMessage: WasmMessage$Type;
export {};
