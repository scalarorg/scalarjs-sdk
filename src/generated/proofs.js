// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "proofs.proto" (package "ics23", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf enum ics23.HashOp
 */
export var HashOp;
(function (HashOp) {
    /**
     * NO_HASH is the default if no data passed. Note this is an illegal argument some places.
     *
     * @generated from protobuf enum value: NO_HASH = 0;
     */
    HashOp[HashOp["NO_HASH"] = 0] = "NO_HASH";
    /**
     * @generated from protobuf enum value: SHA256 = 1;
     */
    HashOp[HashOp["SHA256"] = 1] = "SHA256";
    /**
     * @generated from protobuf enum value: SHA512 = 2;
     */
    HashOp[HashOp["SHA512"] = 2] = "SHA512";
    /**
     * @generated from protobuf enum value: KECCAK = 3;
     */
    HashOp[HashOp["KECCAK"] = 3] = "KECCAK";
    /**
     * @generated from protobuf enum value: RIPEMD160 = 4;
     */
    HashOp[HashOp["RIPEMD160"] = 4] = "RIPEMD160";
    /**
     * ripemd160(sha256(x))
     *
     * @generated from protobuf enum value: BITCOIN = 5;
     */
    HashOp[HashOp["BITCOIN"] = 5] = "BITCOIN";
    /**
     * @generated from protobuf enum value: SHA512_256 = 6;
     */
    HashOp[HashOp["SHA512_256"] = 6] = "SHA512_256";
})(HashOp || (HashOp = {}));
/**
 * *
 * LengthOp defines how to process the key and value of the LeafOp
 * to include length information. After encoding the length with the given
 * algorithm, the length will be prepended to the key and value bytes.
 * (Each one with it's own encoded length)
 *
 * @generated from protobuf enum ics23.LengthOp
 */
export var LengthOp;
(function (LengthOp) {
    /**
     * NO_PREFIX don't include any length info
     *
     * @generated from protobuf enum value: NO_PREFIX = 0;
     */
    LengthOp[LengthOp["NO_PREFIX"] = 0] = "NO_PREFIX";
    /**
     * VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
     *
     * @generated from protobuf enum value: VAR_PROTO = 1;
     */
    LengthOp[LengthOp["VAR_PROTO"] = 1] = "VAR_PROTO";
    /**
     * VAR_RLP uses rlp int encoding of the length
     *
     * @generated from protobuf enum value: VAR_RLP = 2;
     */
    LengthOp[LengthOp["VAR_RLP"] = 2] = "VAR_RLP";
    /**
     * FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
     *
     * @generated from protobuf enum value: FIXED32_BIG = 3;
     */
    LengthOp[LengthOp["FIXED32_BIG"] = 3] = "FIXED32_BIG";
    /**
     * FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
     *
     * @generated from protobuf enum value: FIXED32_LITTLE = 4;
     */
    LengthOp[LengthOp["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
    /**
     * FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
     *
     * @generated from protobuf enum value: FIXED64_BIG = 5;
     */
    LengthOp[LengthOp["FIXED64_BIG"] = 5] = "FIXED64_BIG";
    /**
     * FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
     *
     * @generated from protobuf enum value: FIXED64_LITTLE = 6;
     */
    LengthOp[LengthOp["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
    /**
     * REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
     *
     * @generated from protobuf enum value: REQUIRE_32_BYTES = 7;
     */
    LengthOp[LengthOp["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
    /**
     * REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
     *
     * @generated from protobuf enum value: REQUIRE_64_BYTES = 8;
     */
    LengthOp[LengthOp["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
})(LengthOp || (LengthOp = {}));
// @generated message type with reflection information, may provide speed optimized methods
class ExistenceProof$Type extends MessageType {
    constructor() {
        super("ics23.ExistenceProof", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "leaf", kind: "message", T: () => LeafOp },
            { no: 4, name: "path", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InnerOp }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.key = new Uint8Array(0);
        message.value = new Uint8Array(0);
        message.path = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                case /* ics23.LeafOp leaf */ 3:
                    message.leaf = LeafOp.internalBinaryRead(reader, reader.uint32(), options, message.leaf);
                    break;
                case /* repeated ics23.InnerOp path */ 4:
                    message.path.push(InnerOp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        /* ics23.LeafOp leaf = 3; */
        if (message.leaf)
            LeafOp.internalBinaryWrite(message.leaf, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated ics23.InnerOp path = 4; */
        for (let i = 0; i < message.path.length; i++)
            InnerOp.internalBinaryWrite(message.path[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.ExistenceProof
 */
export const ExistenceProof = new ExistenceProof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NonExistenceProof$Type extends MessageType {
    constructor() {
        super("ics23.NonExistenceProof", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "left", kind: "message", T: () => ExistenceProof },
            { no: 3, name: "right", kind: "message", T: () => ExistenceProof }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.key = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* ics23.ExistenceProof left */ 2:
                    message.left = ExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.left);
                    break;
                case /* ics23.ExistenceProof right */ 3:
                    message.right = ExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.right);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* ics23.ExistenceProof left = 2; */
        if (message.left)
            ExistenceProof.internalBinaryWrite(message.left, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ics23.ExistenceProof right = 3; */
        if (message.right)
            ExistenceProof.internalBinaryWrite(message.right, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.NonExistenceProof
 */
export const NonExistenceProof = new NonExistenceProof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommitmentProof$Type extends MessageType {
    constructor() {
        super("ics23.CommitmentProof", [
            { no: 1, name: "exist", kind: "message", oneof: "proof", T: () => ExistenceProof },
            { no: 2, name: "nonexist", kind: "message", oneof: "proof", T: () => NonExistenceProof },
            { no: 3, name: "batch", kind: "message", oneof: "proof", T: () => BatchProof },
            { no: 4, name: "compressed", kind: "message", oneof: "proof", T: () => CompressedBatchProof }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.proof = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ics23.ExistenceProof exist */ 1:
                    message.proof = {
                        oneofKind: "exist",
                        exist: ExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.exist)
                    };
                    break;
                case /* ics23.NonExistenceProof nonexist */ 2:
                    message.proof = {
                        oneofKind: "nonexist",
                        nonexist: NonExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.nonexist)
                    };
                    break;
                case /* ics23.BatchProof batch */ 3:
                    message.proof = {
                        oneofKind: "batch",
                        batch: BatchProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.batch)
                    };
                    break;
                case /* ics23.CompressedBatchProof compressed */ 4:
                    message.proof = {
                        oneofKind: "compressed",
                        compressed: CompressedBatchProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.compressed)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* ics23.ExistenceProof exist = 1; */
        if (message.proof.oneofKind === "exist")
            ExistenceProof.internalBinaryWrite(message.proof.exist, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ics23.NonExistenceProof nonexist = 2; */
        if (message.proof.oneofKind === "nonexist")
            NonExistenceProof.internalBinaryWrite(message.proof.nonexist, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ics23.BatchProof batch = 3; */
        if (message.proof.oneofKind === "batch")
            BatchProof.internalBinaryWrite(message.proof.batch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ics23.CompressedBatchProof compressed = 4; */
        if (message.proof.oneofKind === "compressed")
            CompressedBatchProof.internalBinaryWrite(message.proof.compressed, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.CommitmentProof
 */
export const CommitmentProof = new CommitmentProof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeafOp$Type extends MessageType {
    constructor() {
        super("ics23.LeafOp", [
            { no: 1, name: "hash", kind: "enum", T: () => ["ics23.HashOp", HashOp] },
            { no: 2, name: "prehash_key", kind: "enum", T: () => ["ics23.HashOp", HashOp] },
            { no: 3, name: "prehash_value", kind: "enum", T: () => ["ics23.HashOp", HashOp] },
            { no: 4, name: "length", kind: "enum", T: () => ["ics23.LengthOp", LengthOp] },
            { no: 5, name: "prefix", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.hash = 0;
        message.prehashKey = 0;
        message.prehashValue = 0;
        message.length = 0;
        message.prefix = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ics23.HashOp hash */ 1:
                    message.hash = reader.int32();
                    break;
                case /* ics23.HashOp prehash_key */ 2:
                    message.prehashKey = reader.int32();
                    break;
                case /* ics23.HashOp prehash_value */ 3:
                    message.prehashValue = reader.int32();
                    break;
                case /* ics23.LengthOp length */ 4:
                    message.length = reader.int32();
                    break;
                case /* bytes prefix */ 5:
                    message.prefix = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* ics23.HashOp hash = 1; */
        if (message.hash !== 0)
            writer.tag(1, WireType.Varint).int32(message.hash);
        /* ics23.HashOp prehash_key = 2; */
        if (message.prehashKey !== 0)
            writer.tag(2, WireType.Varint).int32(message.prehashKey);
        /* ics23.HashOp prehash_value = 3; */
        if (message.prehashValue !== 0)
            writer.tag(3, WireType.Varint).int32(message.prehashValue);
        /* ics23.LengthOp length = 4; */
        if (message.length !== 0)
            writer.tag(4, WireType.Varint).int32(message.length);
        /* bytes prefix = 5; */
        if (message.prefix.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.prefix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.LeafOp
 */
export const LeafOp = new LeafOp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InnerOp$Type extends MessageType {
    constructor() {
        super("ics23.InnerOp", [
            { no: 1, name: "hash", kind: "enum", T: () => ["ics23.HashOp", HashOp] },
            { no: 2, name: "prefix", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "suffix", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.hash = 0;
        message.prefix = new Uint8Array(0);
        message.suffix = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ics23.HashOp hash */ 1:
                    message.hash = reader.int32();
                    break;
                case /* bytes prefix */ 2:
                    message.prefix = reader.bytes();
                    break;
                case /* bytes suffix */ 3:
                    message.suffix = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* ics23.HashOp hash = 1; */
        if (message.hash !== 0)
            writer.tag(1, WireType.Varint).int32(message.hash);
        /* bytes prefix = 2; */
        if (message.prefix.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.prefix);
        /* bytes suffix = 3; */
        if (message.suffix.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.suffix);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.InnerOp
 */
export const InnerOp = new InnerOp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProofSpec$Type extends MessageType {
    constructor() {
        super("ics23.ProofSpec", [
            { no: 1, name: "leaf_spec", kind: "message", T: () => LeafOp },
            { no: 2, name: "inner_spec", kind: "message", T: () => InnerSpec },
            { no: 3, name: "max_depth", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "min_depth", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.maxDepth = 0;
        message.minDepth = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ics23.LeafOp leaf_spec */ 1:
                    message.leafSpec = LeafOp.internalBinaryRead(reader, reader.uint32(), options, message.leafSpec);
                    break;
                case /* ics23.InnerSpec inner_spec */ 2:
                    message.innerSpec = InnerSpec.internalBinaryRead(reader, reader.uint32(), options, message.innerSpec);
                    break;
                case /* int32 max_depth */ 3:
                    message.maxDepth = reader.int32();
                    break;
                case /* int32 min_depth */ 4:
                    message.minDepth = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* ics23.LeafOp leaf_spec = 1; */
        if (message.leafSpec)
            LeafOp.internalBinaryWrite(message.leafSpec, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ics23.InnerSpec inner_spec = 2; */
        if (message.innerSpec)
            InnerSpec.internalBinaryWrite(message.innerSpec, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int32 max_depth = 3; */
        if (message.maxDepth !== 0)
            writer.tag(3, WireType.Varint).int32(message.maxDepth);
        /* int32 min_depth = 4; */
        if (message.minDepth !== 0)
            writer.tag(4, WireType.Varint).int32(message.minDepth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.ProofSpec
 */
export const ProofSpec = new ProofSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InnerSpec$Type extends MessageType {
    constructor() {
        super("ics23.InnerSpec", [
            { no: 1, name: "child_order", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "child_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "min_prefix_length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "max_prefix_length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "empty_child", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "hash", kind: "enum", T: () => ["ics23.HashOp", HashOp] }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.childOrder = [];
        message.childSize = 0;
        message.minPrefixLength = 0;
        message.maxPrefixLength = 0;
        message.emptyChild = new Uint8Array(0);
        message.hash = 0;
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 child_order */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.childOrder.push(reader.int32());
                    else
                        message.childOrder.push(reader.int32());
                    break;
                case /* int32 child_size */ 2:
                    message.childSize = reader.int32();
                    break;
                case /* int32 min_prefix_length */ 3:
                    message.minPrefixLength = reader.int32();
                    break;
                case /* int32 max_prefix_length */ 4:
                    message.maxPrefixLength = reader.int32();
                    break;
                case /* bytes empty_child */ 5:
                    message.emptyChild = reader.bytes();
                    break;
                case /* ics23.HashOp hash */ 6:
                    message.hash = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated int32 child_order = 1; */
        if (message.childOrder.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.childOrder.length; i++)
                writer.int32(message.childOrder[i]);
            writer.join();
        }
        /* int32 child_size = 2; */
        if (message.childSize !== 0)
            writer.tag(2, WireType.Varint).int32(message.childSize);
        /* int32 min_prefix_length = 3; */
        if (message.minPrefixLength !== 0)
            writer.tag(3, WireType.Varint).int32(message.minPrefixLength);
        /* int32 max_prefix_length = 4; */
        if (message.maxPrefixLength !== 0)
            writer.tag(4, WireType.Varint).int32(message.maxPrefixLength);
        /* bytes empty_child = 5; */
        if (message.emptyChild.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.emptyChild);
        /* ics23.HashOp hash = 6; */
        if (message.hash !== 0)
            writer.tag(6, WireType.Varint).int32(message.hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.InnerSpec
 */
export const InnerSpec = new InnerSpec$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchProof$Type extends MessageType {
    constructor() {
        super("ics23.BatchProof", [
            { no: 1, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BatchEntry }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ics23.BatchEntry entries */ 1:
                    message.entries.push(BatchEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated ics23.BatchEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            BatchEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.BatchProof
 */
export const BatchProof = new BatchProof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchEntry$Type extends MessageType {
    constructor() {
        super("ics23.BatchEntry", [
            { no: 1, name: "exist", kind: "message", oneof: "proof", T: () => ExistenceProof },
            { no: 2, name: "nonexist", kind: "message", oneof: "proof", T: () => NonExistenceProof }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.proof = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ics23.ExistenceProof exist */ 1:
                    message.proof = {
                        oneofKind: "exist",
                        exist: ExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.exist)
                    };
                    break;
                case /* ics23.NonExistenceProof nonexist */ 2:
                    message.proof = {
                        oneofKind: "nonexist",
                        nonexist: NonExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.nonexist)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* ics23.ExistenceProof exist = 1; */
        if (message.proof.oneofKind === "exist")
            ExistenceProof.internalBinaryWrite(message.proof.exist, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ics23.NonExistenceProof nonexist = 2; */
        if (message.proof.oneofKind === "nonexist")
            NonExistenceProof.internalBinaryWrite(message.proof.nonexist, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.BatchEntry
 */
export const BatchEntry = new BatchEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompressedBatchProof$Type extends MessageType {
    constructor() {
        super("ics23.CompressedBatchProof", [
            { no: 1, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CompressedBatchEntry },
            { no: 2, name: "lookup_inners", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InnerOp }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.entries = [];
        message.lookupInners = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ics23.CompressedBatchEntry entries */ 1:
                    message.entries.push(CompressedBatchEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ics23.InnerOp lookup_inners */ 2:
                    message.lookupInners.push(InnerOp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated ics23.CompressedBatchEntry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            CompressedBatchEntry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ics23.InnerOp lookup_inners = 2; */
        for (let i = 0; i < message.lookupInners.length; i++)
            InnerOp.internalBinaryWrite(message.lookupInners[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.CompressedBatchProof
 */
export const CompressedBatchProof = new CompressedBatchProof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompressedBatchEntry$Type extends MessageType {
    constructor() {
        super("ics23.CompressedBatchEntry", [
            { no: 1, name: "exist", kind: "message", oneof: "proof", T: () => CompressedExistenceProof },
            { no: 2, name: "nonexist", kind: "message", oneof: "proof", T: () => CompressedNonExistenceProof }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.proof = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ics23.CompressedExistenceProof exist */ 1:
                    message.proof = {
                        oneofKind: "exist",
                        exist: CompressedExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.exist)
                    };
                    break;
                case /* ics23.CompressedNonExistenceProof nonexist */ 2:
                    message.proof = {
                        oneofKind: "nonexist",
                        nonexist: CompressedNonExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.proof.nonexist)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* ics23.CompressedExistenceProof exist = 1; */
        if (message.proof.oneofKind === "exist")
            CompressedExistenceProof.internalBinaryWrite(message.proof.exist, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ics23.CompressedNonExistenceProof nonexist = 2; */
        if (message.proof.oneofKind === "nonexist")
            CompressedNonExistenceProof.internalBinaryWrite(message.proof.nonexist, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.CompressedBatchEntry
 */
export const CompressedBatchEntry = new CompressedBatchEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompressedExistenceProof$Type extends MessageType {
    constructor() {
        super("ics23.CompressedExistenceProof", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "leaf", kind: "message", T: () => LeafOp },
            { no: 4, name: "path", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.key = new Uint8Array(0);
        message.value = new Uint8Array(0);
        message.path = [];
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* bytes value */ 2:
                    message.value = reader.bytes();
                    break;
                case /* ics23.LeafOp leaf */ 3:
                    message.leaf = LeafOp.internalBinaryRead(reader, reader.uint32(), options, message.leaf);
                    break;
                case /* repeated int32 path */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.path.push(reader.int32());
                    else
                        message.path.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* bytes value = 2; */
        if (message.value.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.value);
        /* ics23.LeafOp leaf = 3; */
        if (message.leaf)
            LeafOp.internalBinaryWrite(message.leaf, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 path = 4; */
        if (message.path.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.path.length; i++)
                writer.int32(message.path[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.CompressedExistenceProof
 */
export const CompressedExistenceProof = new CompressedExistenceProof$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompressedNonExistenceProof$Type extends MessageType {
    constructor() {
        super("ics23.CompressedNonExistenceProof", [
            { no: 1, name: "key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "left", kind: "message", T: () => CompressedExistenceProof },
            { no: 3, name: "right", kind: "message", T: () => CompressedExistenceProof }
        ]);
    }
    create(value) {
        const message = globalThis.Object.create((this.messagePrototype));
        message.key = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key */ 1:
                    message.key = reader.bytes();
                    break;
                case /* ics23.CompressedExistenceProof left */ 2:
                    message.left = CompressedExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.left);
                    break;
                case /* ics23.CompressedExistenceProof right */ 3:
                    message.right = CompressedExistenceProof.internalBinaryRead(reader, reader.uint32(), options, message.right);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes key = 1; */
        if (message.key.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.key);
        /* ics23.CompressedExistenceProof left = 2; */
        if (message.left)
            CompressedExistenceProof.internalBinaryWrite(message.left, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ics23.CompressedExistenceProof right = 3; */
        if (message.right)
            CompressedExistenceProof.internalBinaryWrite(message.right, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ics23.CompressedNonExistenceProof
 */
export const CompressedNonExistenceProof = new CompressedNonExistenceProof$Type();
