// @generated by protobuf-ts 2.9.4 with parameter long_type_string,output_javascript_es2015,generate_dependencies
// @generated from protobuf file "axelar/evm/v1beta1/types.proto" (package "axelar.evm.v1beta1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../../google/protobuf/any";
/**
 * @generated from protobuf message axelar.evm.v1beta1.VoteEvents
 */
export interface VoteEvents {
    /**
     * @generated from protobuf field: string chain = 1;
     */
    chain: string;
    /**
     * @generated from protobuf field: repeated axelar.evm.v1beta1.Event events = 2;
     */
    events: Event[];
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.Event
 */
export interface Event {
    /**
     * @generated from protobuf field: string chain = 1;
     */
    chain: string;
    /**
     * @generated from protobuf field: bytes tx_id = 2;
     */
    txId: Uint8Array;
    /**
     * @generated from protobuf field: uint64 index = 3;
     */
    index: string;
    /**
     * @generated from protobuf field: axelar.evm.v1beta1.Event.Status status = 4;
     */
    status: Event_Status;
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "tokenSent";
        /**
         * @generated from protobuf field: axelar.evm.v1beta1.EventTokenSent token_sent = 5;
         */
        tokenSent: EventTokenSent;
    } | {
        oneofKind: "contractCall";
        /**
         * @generated from protobuf field: axelar.evm.v1beta1.EventContractCall contract_call = 6;
         */
        contractCall: EventContractCall;
    } | {
        oneofKind: "contractCallWithToken";
        /**
         * @generated from protobuf field: axelar.evm.v1beta1.EventContractCallWithToken contract_call_with_token = 7;
         */
        contractCallWithToken: EventContractCallWithToken;
    } | {
        oneofKind: "transfer";
        /**
         * @generated from protobuf field: axelar.evm.v1beta1.EventTransfer transfer = 8;
         */
        transfer: EventTransfer;
    } | {
        oneofKind: "tokenDeployed";
        /**
         * @generated from protobuf field: axelar.evm.v1beta1.EventTokenDeployed token_deployed = 9;
         */
        tokenDeployed: EventTokenDeployed;
    } | {
        oneofKind: "multisigOwnershipTransferred";
        /**
         * @deprecated
         * @generated from protobuf field: axelar.evm.v1beta1.EventMultisigOwnershipTransferred multisig_ownership_transferred = 10 [deprecated = true];
         */
        multisigOwnershipTransferred: EventMultisigOwnershipTransferred;
    } | {
        oneofKind: "multisigOperatorshipTransferred";
        /**
         * @generated from protobuf field: axelar.evm.v1beta1.EventMultisigOperatorshipTransferred multisig_operatorship_transferred = 11;
         */
        multisigOperatorshipTransferred: EventMultisigOperatorshipTransferred;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum axelar.evm.v1beta1.Event.Status
 */
export declare enum Event_Status {
    /**
     * @generated from protobuf enum value: STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STATUS_CONFIRMED = 1;
     */
    CONFIRMED = 1,
    /**
     * @generated from protobuf enum value: STATUS_COMPLETED = 2;
     */
    COMPLETED = 2,
    /**
     * @generated from protobuf enum value: STATUS_FAILED = 3;
     */
    FAILED = 3
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.EventTokenSent
 */
export interface EventTokenSent {
    /**
     * @generated from protobuf field: bytes sender = 1;
     */
    sender: Uint8Array;
    /**
     * @generated from protobuf field: string destination_chain = 2;
     */
    destinationChain: string;
    /**
     * @generated from protobuf field: string destination_address = 3;
     */
    destinationAddress: string;
    /**
     * @generated from protobuf field: string symbol = 4;
     */
    symbol: string;
    /**
     * @generated from protobuf field: bytes amount = 5;
     */
    amount: Uint8Array;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.EventContractCall
 */
export interface EventContractCall {
    /**
     * @generated from protobuf field: bytes sender = 1;
     */
    sender: Uint8Array;
    /**
     * @generated from protobuf field: string destination_chain = 2;
     */
    destinationChain: string;
    /**
     * @generated from protobuf field: string contract_address = 3;
     */
    contractAddress: string;
    /**
     * @generated from protobuf field: bytes payload_hash = 4;
     */
    payloadHash: Uint8Array;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.EventContractCallWithToken
 */
export interface EventContractCallWithToken {
    /**
     * @generated from protobuf field: bytes sender = 1;
     */
    sender: Uint8Array;
    /**
     * @generated from protobuf field: string destination_chain = 2;
     */
    destinationChain: string;
    /**
     * @generated from protobuf field: string contract_address = 3;
     */
    contractAddress: string;
    /**
     * @generated from protobuf field: bytes payload_hash = 4;
     */
    payloadHash: Uint8Array;
    /**
     * @generated from protobuf field: string symbol = 5;
     */
    symbol: string;
    /**
     * @generated from protobuf field: bytes amount = 6;
     */
    amount: Uint8Array;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.EventTransfer
 */
export interface EventTransfer {
    /**
     * @generated from protobuf field: bytes to = 1;
     */
    to: Uint8Array;
    /**
     * @generated from protobuf field: bytes amount = 2;
     */
    amount: Uint8Array;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.EventTokenDeployed
 */
export interface EventTokenDeployed {
    /**
     * @generated from protobuf field: string symbol = 1;
     */
    symbol: string;
    /**
     * @generated from protobuf field: bytes token_address = 2;
     */
    tokenAddress: Uint8Array;
}
/**
 * @deprecated
 * @generated from protobuf message axelar.evm.v1beta1.EventMultisigOwnershipTransferred
 */
export interface EventMultisigOwnershipTransferred {
    /**
     * @generated from protobuf field: repeated bytes pre_owners = 1;
     */
    preOwners: Uint8Array[];
    /**
     * @generated from protobuf field: bytes prev_threshold = 2;
     */
    prevThreshold: Uint8Array;
    /**
     * @generated from protobuf field: repeated bytes new_owners = 3;
     */
    newOwners: Uint8Array[];
    /**
     * @generated from protobuf field: bytes new_threshold = 4;
     */
    newThreshold: Uint8Array;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.EventMultisigOperatorshipTransferred
 */
export interface EventMultisigOperatorshipTransferred {
    /**
     * @generated from protobuf field: repeated bytes new_operators = 3;
     */
    newOperators: Uint8Array[];
    /**
     * @generated from protobuf field: bytes new_threshold = 4;
     */
    newThreshold: Uint8Array;
    /**
     * @generated from protobuf field: repeated bytes new_weights = 5;
     */
    newWeights: Uint8Array[];
}
/**
 * NetworkInfo describes information about a network
 *
 * @generated from protobuf message axelar.evm.v1beta1.NetworkInfo
 */
export interface NetworkInfo {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: bytes id = 2;
     */
    id: Uint8Array;
}
/**
 * BurnerInfo describes information required to burn token at an burner address
 * that is deposited by an user
 *
 * @generated from protobuf message axelar.evm.v1beta1.BurnerInfo
 */
export interface BurnerInfo {
    /**
     * @generated from protobuf field: bytes burner_address = 1;
     */
    burnerAddress: Uint8Array;
    /**
     * @generated from protobuf field: bytes token_address = 2;
     */
    tokenAddress: Uint8Array;
    /**
     * @generated from protobuf field: string destination_chain = 3;
     */
    destinationChain: string;
    /**
     * @generated from protobuf field: string symbol = 4;
     */
    symbol: string;
    /**
     * @generated from protobuf field: string asset = 5;
     */
    asset: string;
    /**
     * @generated from protobuf field: bytes salt = 6;
     */
    salt: Uint8Array;
}
/**
 * ERC20Deposit contains information for an ERC20 deposit
 *
 * @generated from protobuf message axelar.evm.v1beta1.ERC20Deposit
 */
export interface ERC20Deposit {
    /**
     * @generated from protobuf field: bytes tx_id = 1;
     */
    txId: Uint8Array;
    /**
     * @generated from protobuf field: bytes amount = 2;
     */
    amount: Uint8Array;
    /**
     * @generated from protobuf field: string asset = 3;
     */
    asset: string;
    /**
     * @generated from protobuf field: string destination_chain = 4;
     */
    destinationChain: string;
    /**
     * @generated from protobuf field: bytes burner_address = 5;
     */
    burnerAddress: Uint8Array;
    /**
     * @generated from protobuf field: uint64 log_index = 6;
     */
    logIndex: string;
}
/**
 * ERC20TokenMetadata describes information about an ERC20 token
 *
 * @generated from protobuf message axelar.evm.v1beta1.ERC20TokenMetadata
 */
export interface ERC20TokenMetadata {
    /**
     * @generated from protobuf field: string asset = 1;
     */
    asset: string;
    /**
     * @generated from protobuf field: bytes chain_id = 2;
     */
    chainId: Uint8Array;
    /**
     * @generated from protobuf field: axelar.evm.v1beta1.TokenDetails details = 3;
     */
    details?: TokenDetails;
    /**
     * @generated from protobuf field: string token_address = 4;
     */
    tokenAddress: string;
    /**
     * @generated from protobuf field: string tx_hash = 5;
     */
    txHash: string;
    /**
     * @generated from protobuf field: axelar.evm.v1beta1.Status status = 7;
     */
    status: Status;
    /**
     * @generated from protobuf field: bool is_external = 8;
     */
    isExternal: boolean;
    /**
     * @generated from protobuf field: bytes burner_code = 9;
     */
    burnerCode: Uint8Array;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.TransactionMetadata
 */
export interface TransactionMetadata {
    /**
     * @generated from protobuf field: bytes raw_tx = 1;
     */
    rawTx: Uint8Array;
    /**
     * @generated from protobuf field: bytes pub_key = 2;
     */
    pubKey: Uint8Array;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.Command
 */
export interface Command {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * @deprecated
     * @generated from protobuf field: string command = 2 [deprecated = true];
     */
    command: string;
    /**
     * @generated from protobuf field: bytes params = 3;
     */
    params: Uint8Array;
    /**
     * @generated from protobuf field: string key_id = 4;
     */
    keyId: string;
    /**
     * @generated from protobuf field: uint32 max_gas_cost = 5;
     */
    maxGasCost: number;
    /**
     * @generated from protobuf field: axelar.evm.v1beta1.CommandType type = 6;
     */
    type: CommandType;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.CommandBatchMetadata
 */
export interface CommandBatchMetadata {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: repeated bytes command_ids = 2;
     */
    commandIds: Uint8Array[];
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bytes sig_hash = 4;
     */
    sigHash: Uint8Array;
    /**
     * @generated from protobuf field: axelar.evm.v1beta1.BatchedCommandsStatus status = 5;
     */
    status: BatchedCommandsStatus;
    /**
     * @generated from protobuf field: string key_id = 6;
     */
    keyId: string;
    /**
     * @generated from protobuf field: bytes prev_batched_commands_id = 7;
     */
    prevBatchedCommandsId: Uint8Array;
    /**
     * @generated from protobuf field: google.protobuf.Any signature = 8;
     */
    signature?: Any;
}
/**
 * SigMetadata stores necessary information for external apps to map signature
 * results to evm relay transaction types
 *
 * @generated from protobuf message axelar.evm.v1beta1.SigMetadata
 */
export interface SigMetadata {
    /**
     * @generated from protobuf field: axelar.evm.v1beta1.SigType type = 1;
     */
    type: SigType;
    /**
     * @generated from protobuf field: string chain = 2;
     */
    chain: string;
    /**
     * @generated from protobuf field: bytes command_batch_id = 3;
     */
    commandBatchId: Uint8Array;
}
/**
 * TransferKey contains information for a transfer operatorship
 *
 * @generated from protobuf message axelar.evm.v1beta1.TransferKey
 */
export interface TransferKey {
    /**
     * @generated from protobuf field: bytes tx_id = 1;
     */
    txId: Uint8Array;
    /**
     * @generated from protobuf field: string next_key_id = 3;
     */
    nextKeyId: string;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.Asset
 */
export interface Asset {
    /**
     * @generated from protobuf field: string chain = 1;
     */
    chain: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.TokenDetails
 */
export interface TokenDetails {
    /**
     * @generated from protobuf field: string token_name = 1;
     */
    tokenName: string;
    /**
     * @generated from protobuf field: string symbol = 2;
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint32 decimals = 3;
     */
    decimals: number;
    /**
     * @generated from protobuf field: bytes capacity = 4;
     */
    capacity: Uint8Array;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.Gateway
 */
export interface Gateway {
    /**
     * @generated from protobuf field: bytes address = 1;
     */
    address: Uint8Array;
}
/**
 * @generated from protobuf message axelar.evm.v1beta1.PollMetadata
 */
export interface PollMetadata {
    /**
     * @generated from protobuf field: string chain = 1;
     */
    chain: string;
    /**
     * @generated from protobuf field: bytes tx_id = 2;
     */
    txId: Uint8Array;
}
/**
 * @generated from protobuf enum axelar.evm.v1beta1.Status
 */
export declare enum Status {
    /**
     * these enum values are used for bitwise operations, therefore they need to
     * be powers of 2
     *
     * @generated from protobuf enum value: STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STATUS_INITIALIZED = 1;
     */
    INITIALIZED = 1,
    /**
     * @generated from protobuf enum value: STATUS_PENDING = 2;
     */
    PENDING = 2,
    /**
     * @generated from protobuf enum value: STATUS_CONFIRMED = 4;
     */
    CONFIRMED = 4
}
/**
 * @generated from protobuf enum axelar.evm.v1beta1.CommandType
 */
export declare enum CommandType {
    /**
     * @generated from protobuf enum value: COMMAND_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: COMMAND_TYPE_MINT_TOKEN = 1;
     */
    MINT_TOKEN = 1,
    /**
     * @generated from protobuf enum value: COMMAND_TYPE_DEPLOY_TOKEN = 2;
     */
    DEPLOY_TOKEN = 2,
    /**
     * @generated from protobuf enum value: COMMAND_TYPE_BURN_TOKEN = 3;
     */
    BURN_TOKEN = 3,
    /**
     * @generated from protobuf enum value: COMMAND_TYPE_TRANSFER_OPERATORSHIP = 4;
     */
    TRANSFER_OPERATORSHIP = 4,
    /**
     * @generated from protobuf enum value: COMMAND_TYPE_APPROVE_CONTRACT_CALL_WITH_MINT = 5;
     */
    APPROVE_CONTRACT_CALL_WITH_MINT = 5,
    /**
     * @generated from protobuf enum value: COMMAND_TYPE_APPROVE_CONTRACT_CALL = 6;
     */
    APPROVE_CONTRACT_CALL = 6
}
/**
 * @generated from protobuf enum axelar.evm.v1beta1.BatchedCommandsStatus
 */
export declare enum BatchedCommandsStatus {
    /**
     * @generated from protobuf enum value: BATCHED_COMMANDS_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: BATCHED_COMMANDS_STATUS_SIGNING = 1;
     */
    SIGNING = 1,
    /**
     * @generated from protobuf enum value: BATCHED_COMMANDS_STATUS_ABORTED = 2;
     */
    ABORTED = 2,
    /**
     * @generated from protobuf enum value: BATCHED_COMMANDS_STATUS_SIGNED = 3;
     */
    SIGNED = 3
}
/**
 * @generated from protobuf enum axelar.evm.v1beta1.SigType
 */
export declare enum SigType {
    /**
     * @generated from protobuf enum value: SIG_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SIG_TYPE_TX = 1;
     */
    TX = 1,
    /**
     * @generated from protobuf enum value: SIG_TYPE_COMMAND = 2;
     */
    COMMAND = 2
}
/**
 * @generated from protobuf enum axelar.evm.v1beta1.DepositStatus
 */
export declare enum DepositStatus {
    /**
     * @generated from protobuf enum value: DEPOSIT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DEPOSIT_STATUS_PENDING = 1;
     */
    PENDING = 1,
    /**
     * @generated from protobuf enum value: DEPOSIT_STATUS_CONFIRMED = 2;
     */
    CONFIRMED = 2,
    /**
     * @generated from protobuf enum value: DEPOSIT_STATUS_BURNED = 3;
     */
    BURNED = 3
}
declare class VoteEvents$Type extends MessageType<VoteEvents> {
    constructor();
    create(value?: PartialMessage<VoteEvents>): VoteEvents;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoteEvents): VoteEvents;
    internalBinaryWrite(message: VoteEvents, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.VoteEvents
 */
export declare const VoteEvents: VoteEvents$Type;
declare class Event$Type extends MessageType<Event> {
    constructor();
    create(value?: PartialMessage<Event>): Event;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event;
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.Event
 */
export declare const Event: Event$Type;
declare class EventTokenSent$Type extends MessageType<EventTokenSent> {
    constructor();
    create(value?: PartialMessage<EventTokenSent>): EventTokenSent;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventTokenSent): EventTokenSent;
    internalBinaryWrite(message: EventTokenSent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.EventTokenSent
 */
export declare const EventTokenSent: EventTokenSent$Type;
declare class EventContractCall$Type extends MessageType<EventContractCall> {
    constructor();
    create(value?: PartialMessage<EventContractCall>): EventContractCall;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventContractCall): EventContractCall;
    internalBinaryWrite(message: EventContractCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.EventContractCall
 */
export declare const EventContractCall: EventContractCall$Type;
declare class EventContractCallWithToken$Type extends MessageType<EventContractCallWithToken> {
    constructor();
    create(value?: PartialMessage<EventContractCallWithToken>): EventContractCallWithToken;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventContractCallWithToken): EventContractCallWithToken;
    internalBinaryWrite(message: EventContractCallWithToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.EventContractCallWithToken
 */
export declare const EventContractCallWithToken: EventContractCallWithToken$Type;
declare class EventTransfer$Type extends MessageType<EventTransfer> {
    constructor();
    create(value?: PartialMessage<EventTransfer>): EventTransfer;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventTransfer): EventTransfer;
    internalBinaryWrite(message: EventTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.EventTransfer
 */
export declare const EventTransfer: EventTransfer$Type;
declare class EventTokenDeployed$Type extends MessageType<EventTokenDeployed> {
    constructor();
    create(value?: PartialMessage<EventTokenDeployed>): EventTokenDeployed;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventTokenDeployed): EventTokenDeployed;
    internalBinaryWrite(message: EventTokenDeployed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.EventTokenDeployed
 */
export declare const EventTokenDeployed: EventTokenDeployed$Type;
declare class EventMultisigOwnershipTransferred$Type extends MessageType<EventMultisigOwnershipTransferred> {
    constructor();
    create(value?: PartialMessage<EventMultisigOwnershipTransferred>): EventMultisigOwnershipTransferred;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventMultisigOwnershipTransferred): EventMultisigOwnershipTransferred;
    internalBinaryWrite(message: EventMultisigOwnershipTransferred, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @deprecated
 * @generated MessageType for protobuf message axelar.evm.v1beta1.EventMultisigOwnershipTransferred
 */
export declare const EventMultisigOwnershipTransferred: EventMultisigOwnershipTransferred$Type;
declare class EventMultisigOperatorshipTransferred$Type extends MessageType<EventMultisigOperatorshipTransferred> {
    constructor();
    create(value?: PartialMessage<EventMultisigOperatorshipTransferred>): EventMultisigOperatorshipTransferred;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventMultisigOperatorshipTransferred): EventMultisigOperatorshipTransferred;
    internalBinaryWrite(message: EventMultisigOperatorshipTransferred, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.EventMultisigOperatorshipTransferred
 */
export declare const EventMultisigOperatorshipTransferred: EventMultisigOperatorshipTransferred$Type;
declare class NetworkInfo$Type extends MessageType<NetworkInfo> {
    constructor();
    create(value?: PartialMessage<NetworkInfo>): NetworkInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetworkInfo): NetworkInfo;
    internalBinaryWrite(message: NetworkInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.NetworkInfo
 */
export declare const NetworkInfo: NetworkInfo$Type;
declare class BurnerInfo$Type extends MessageType<BurnerInfo> {
    constructor();
    create(value?: PartialMessage<BurnerInfo>): BurnerInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BurnerInfo): BurnerInfo;
    internalBinaryWrite(message: BurnerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.BurnerInfo
 */
export declare const BurnerInfo: BurnerInfo$Type;
declare class ERC20Deposit$Type extends MessageType<ERC20Deposit> {
    constructor();
    create(value?: PartialMessage<ERC20Deposit>): ERC20Deposit;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20Deposit): ERC20Deposit;
    internalBinaryWrite(message: ERC20Deposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.ERC20Deposit
 */
export declare const ERC20Deposit: ERC20Deposit$Type;
declare class ERC20TokenMetadata$Type extends MessageType<ERC20TokenMetadata> {
    constructor();
    create(value?: PartialMessage<ERC20TokenMetadata>): ERC20TokenMetadata;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20TokenMetadata): ERC20TokenMetadata;
    internalBinaryWrite(message: ERC20TokenMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.ERC20TokenMetadata
 */
export declare const ERC20TokenMetadata: ERC20TokenMetadata$Type;
declare class TransactionMetadata$Type extends MessageType<TransactionMetadata> {
    constructor();
    create(value?: PartialMessage<TransactionMetadata>): TransactionMetadata;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionMetadata): TransactionMetadata;
    internalBinaryWrite(message: TransactionMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.TransactionMetadata
 */
export declare const TransactionMetadata: TransactionMetadata$Type;
declare class Command$Type extends MessageType<Command> {
    constructor();
    create(value?: PartialMessage<Command>): Command;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Command): Command;
    internalBinaryWrite(message: Command, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.Command
 */
export declare const Command: Command$Type;
declare class CommandBatchMetadata$Type extends MessageType<CommandBatchMetadata> {
    constructor();
    create(value?: PartialMessage<CommandBatchMetadata>): CommandBatchMetadata;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CommandBatchMetadata): CommandBatchMetadata;
    internalBinaryWrite(message: CommandBatchMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.CommandBatchMetadata
 */
export declare const CommandBatchMetadata: CommandBatchMetadata$Type;
declare class SigMetadata$Type extends MessageType<SigMetadata> {
    constructor();
    create(value?: PartialMessage<SigMetadata>): SigMetadata;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SigMetadata): SigMetadata;
    internalBinaryWrite(message: SigMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.SigMetadata
 */
export declare const SigMetadata: SigMetadata$Type;
declare class TransferKey$Type extends MessageType<TransferKey> {
    constructor();
    create(value?: PartialMessage<TransferKey>): TransferKey;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransferKey): TransferKey;
    internalBinaryWrite(message: TransferKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.TransferKey
 */
export declare const TransferKey: TransferKey$Type;
declare class Asset$Type extends MessageType<Asset> {
    constructor();
    create(value?: PartialMessage<Asset>): Asset;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Asset): Asset;
    internalBinaryWrite(message: Asset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.Asset
 */
export declare const Asset: Asset$Type;
declare class TokenDetails$Type extends MessageType<TokenDetails> {
    constructor();
    create(value?: PartialMessage<TokenDetails>): TokenDetails;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenDetails): TokenDetails;
    internalBinaryWrite(message: TokenDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.TokenDetails
 */
export declare const TokenDetails: TokenDetails$Type;
declare class Gateway$Type extends MessageType<Gateway> {
    constructor();
    create(value?: PartialMessage<Gateway>): Gateway;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gateway): Gateway;
    internalBinaryWrite(message: Gateway, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.Gateway
 */
export declare const Gateway: Gateway$Type;
declare class PollMetadata$Type extends MessageType<PollMetadata> {
    constructor();
    create(value?: PartialMessage<PollMetadata>): PollMetadata;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PollMetadata): PollMetadata;
    internalBinaryWrite(message: PollMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message axelar.evm.v1beta1.PollMetadata
 */
export declare const PollMetadata: PollMetadata$Type;
export {};
